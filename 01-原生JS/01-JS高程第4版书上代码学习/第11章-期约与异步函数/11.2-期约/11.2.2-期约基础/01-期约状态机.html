<!--
 * @Author: liming
 * @Date: 2021-07-31 14:01:10
 * @LastEditTime: 2021-07-31 14:28:36
 * @FilePath: \第11章-期约与异步函数\11.2-期约\11.2.2-期约基础\01-期约状态机.html
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
         在把一个期约实例传给 console.log() 时，控制台输出（可能因浏览器不同而略有差异）表明该
            实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一：
              待定（pending）
              兑现（fulfilled，有时候也称为“解决”，resolved）
              拒绝（rejected）
                
            待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现
            （fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待
            定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组
            织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该
            具有恰当的行为。
                
            重要的是，期约的状态是私有的，不能直接通过 JavaScript 检测到。这主要是为了避免根据读取到
            的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 JavaScript 代码修改。这与不
            能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。
         */
    </script>
    <script>
      /*ECMAScript 6 新增的引用类型 Promise ，可以通过 new 操作符来实例化。创建新期约时需要传入
执行器（executor）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解
释器：*/
      let p = new Promise(() => {});
      console.log(p, "==========");
      setTimeout(() => {
        console.log(p);
      });
      // 之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 SyntaxError 。
    </script>
  </body>
</html>
