<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>

	<body>
		<script>
			function double(value, success, failure) {
				setTimeout(() => {
					try {
						if (typeof value !== 'number') {
							throw 'Must provide number as first argument'
						}
						success(2 * value)
					} catch (e) {
						failure(e)
					}
				}, 1000)
			}

			const successCallback = (x) => console.log(`Success: ${x}`)
			const failureCallback = (e) => console.log(`Failure: ${e}`)
			double(3, successCallback, failureCallback)
			double('b', successCallback, failureCallback)
			// Success: 6（大约 1000 毫秒之后）
			// Failure: Must provide number as first argument（大约 1000 毫秒之后）

            // 这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内
            // 存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。
		</script>
	</body>
</html>
