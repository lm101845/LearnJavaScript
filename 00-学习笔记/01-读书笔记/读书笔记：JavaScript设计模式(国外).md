---
title: 读书笔记：JavaScript设计模式(国外)
date: 2020-10-22 17:00:00
tags: 读书笔记
categories: 前端理论
---

(注1：这本是外国人写的，听说很经典，和国内的那版的交替着看吧。)

( 注2：这本书还是很好的，值得好好去看。)

# 译者序

设计模式对于程序员来说并不是一个陌生话题。在Erich Gamma等人合著的经典著作《设计模式》出版之后，十几年间陆续出现了许多这方面的专著。不过它们大都结合Java和C++等传统的面向对象语言进行讲解，而讲述设计模式在动态语言中的实现的书则较为罕见。在早期的Javascript编程实践中，这种语言只被用于做点为网页涂脂抹粉的小差事；程序的规模很小，也很简单。那个时候恐怕没有人会想到把设计模式用到这种“玩具语言”编写的程序中。随着Ajax技术的兴起，Web应用的许多逻辑都从服务器端转移到客户端执行，客户端JavaScript程序的作用越来越重要，其规模和复杂程度也越来越大，人们也越来越多地把面向对象方法应用到JavaScript程序设计中。在此背景下，有许多人开始研究设计模式在JavaScript程序设计中的应用，网上也陆续出现了一些关于这个话题的零星讨论。但是到目前为止，系统地探讨面向对象的程序设计模式在Javascript语言中的实现的书，只此一本。（Michael Mahemof所著的《Ajax设计模式》一书总结的是运用Ajax技术开发Web应用的各种设计模式，虽然也涉及大量JavaScript编程，但它与本书关注的焦点不同。本书讨论的是一些通用的面向对象设计模式在JavaScript中的实现，属于更基础性的东西，它们不仅仅适用于Web客户端编程。）

Javasript这种语言与Java等传统的面向对象语言有很大的不同。它的动态性、词法作用域和基于原型的继承机制等特点可能会让很多初次接触它的程序员都有点不习惯，而且由于语言设计上的一些不完善，许多在传统面向对象语言中只是举手之劳的事在JavaScipt中却不得不依靠hack手法来实现。这也许就是那些已经熟知设计模式在Java等语言中实现方式的程序员也需要本书的原因。本书第一部分着重讲述了面向对象技术在JavaScript中的实现方法。这对于对JavaScript只有过初步了解的人非常有用（当然，本书不适合对JavaScript一窍不通的读者。他们应该先找一本JavaScript基础教材来看看，比如人民邮电出版社出版的《JavaScript基础教程》），Java和IC++编程老手们在学完这部分内容之后，想必应该能够在JavaScript程序设计中自行应用各种经典的设计模式了。不过不同的人可能会有一些不同的做法，因此继续看看本书第二部分，借鉴一下作者的方法也不无益处。对于那些从未学过设计模式的JavaScript程序员来说，本书的重要性更是毋庸置疑。

不过，坦率地说，要想深入学习设计模式仅看本书是不够的。取代Gamma等人的《设计模式》并不是本书的目标。

就个人的感觉而言，**我觉得本书最大的遗憾之处在于作者在讲述各种设计模式的实现时没有使用原型式继承，而是选择了类式继承**。毕竟原型式继承才是JavaScript面向对象编程最自然的继承实现方式。不过正如作者所言，“有些人似乎天生就容易被原型式继承的简洁性吸引，而另一些人却对更面熟的类式继承情有独钟”，这只是个人口味的问题。考虑到很多人对原型式继承都非常陌生，作者的这种选择可以理解。

# 前言

目前，JavaScript到了一个转折关头。这门语言和它的用户都已经成熟起来。人们也开始认识到：它是一个复杂的课题，值得进一步研究。

设计模式运用在程序设计中已经有些年头了。它们最早被整理记录于Erich Gamma，Richard Helm.Ralph Johnson和John Vlissides（绰号“四人帮”（the Gang of Four，后文中简写为Gof））合著的Design Patterns一书中，现已被应用到各种各样的面向对象语言中。设计模式的魅力之一体现在它们被应用于各种语言和语法上时所表现出的一致性上。其基本结构是相同的，只是细节略有差别。例如，把一个用Java实现的模式转换为C++形式就很容易。

但是对JavaScript来说情况则有所不同。尽管所有那些能力JavaScript都有，但它们往往并非这种语言的正式部分，因而必须借助于一些晦涩的技巧和不那么直观的技术来模仿。这些年来，人们找到了许多方法用该语言来完成其设计者都未曾预计到的任务。那些常见的面向对象特性同样也要靠这样的手段实现。

本书收集整理了这些技巧和技术。第一部分提供了一个实现具体设计模式所需要的面向对象特性的基础。第二部分则专注于各种具体的设计模式及其在JavaScript语言中的应用。

为了让每一章中的示例都尽可能地贴近实际应用，我们花了不少心思。我们尽量列举一些JavaScript程序员最常见的任务，然后运用设计模式使其解决方案变得更模块化、更高效并且更易维护。而那些较为理论化的例子则用于阐明某些要点。我们知道，本书的价值最终将取决于它与你的日常工作和项目的紧密联系程度。

希望你能喜欢这本书。**JavaScript是一种极其复杂而又灵活的语言，而且很适合于动手实践。**
你可以随时试试我们提供的示例代码。要是你找到实现某种设计模式的新方法，或者某种旧技术的新用途，请告诉我们一声。本书的附属网站http:/jsdesignpatterns.com和Apress出版社的网站http://www.apress.com提供了更多信息以及可供下载的示例代码。

# 目标读者

本书主要面向两类读者。第一类读者是懂一点JavaScript并且想要加深对它的认识的Web开发人员或前端工程师，尤其是那些想要增进其对于JavaScript的面向对象能力的理解，学习如何提高其代码的模块化程度、可维护性和效率的人，他们可以从书中学到用JavaScript进行面向对象程序设计的基本知识，还能学到各种具体的设计模式，懂得应该在什么场合使用这些设计模式，以及如何实现它们。这类读者已经比较熟悉JavaScript的基本语法，他们会更多地关注那些关于如何按特定设计模式重构现有代码的部分，以及对于每种模式的适用场合的说明。

第二类读者是一些主要使用Java和C++等服务器端编程语言的程序员，相对而言，他们对JavaScript比较陌生，但又希望能把自己在设计模式和面向对象程序设计方面的知识应用到客户端程序设计中。他们可以从本书中学到如何在JavaScript中实现接口、继承和封装等常见的面向对象特性。这类读者会发现书中的代码尤其有用，因为他们可能不太熟悉JavaScript和其他面向对象语言在语法方面的差别。也许他们对各种具体的设计模式已经比较熟悉，所以本书讲述面向对象技术在JavaScript中的实现方法的第一部分对他们可能更有意义。

那些对JavaScript和面向对象程序设计都不太熟悉的读者可能很难看懂某些示例中的代码。这并不是一本入门级的书，它假定读者已经具备一定的程序设计知识。尽管如此，我们还是尽可能地使自己的讲解做到深入浅出，让不同层次的读者都易于理解。

# 本书结构

![](读书笔记：JavaScript设计模式(国外)/01.png)

# 预备知识

![](读书笔记：JavaScript设计模式(国外)/02.png)

# 第一部分：面向对象的JavaScript

# 第1章：富有表现力的JavaScript

JavaScript是现在最流行、应用最广泛的语言之一。由于所有现代浏览器都嵌入了JavaScript解释器，所以在大多数地方都能见到其身影。作为一种语言，它在我们的日常生活中起着非常重要的作用，支持着我们访问的网站，帮助Web呈现出多姿多彩的界面。

那为什么有些人还把它看作一种玩具式的语言，认为它不值得职业程序员关注呢？我们认为其原因在于，人们没有认清这种语言的全部能力及其在当今的编程世界中的独特性。JavaScript是一种极富表现力的语言，它具有一些C家族语言所罕见的特性。

本章将探讨一些令JavaScript如此富有表现力的特性。从中你可以体会到，这种语言允许你用各种方式完成同样的任务，还允许你在面向对象编程的过程中借用函数式编程中的概念来丰富其实现方式。本章解释了究竟为什么应该使用设计模式，以及它们在JavaScript程序设计的运用是如何使代码更高效、更易于处理的。

## JavaScript的灵活性

JavaScript最强大的特性是其灵活性。作为JavaScript程序员，只要你愿意，可以把程序写得很简单，也可以得很 这种语言也支持多种不同的编程风格。你既可以采用函数式编程风格，也可以采用更复杂一点的对象编程风格。即使你根本不懂函数式编程或面向对象编程，地能写出较为复杂的程序。使用这种语言，哪怕只采用编写一个个简单的函数的方式，你也能高双地完成任务。这可能是某些人把JavaScript视同玩具的原因之一，但我们却认为这是一个优点。
程序员只要使用这种语音的一个很小的、易于学习的子集就能完成一些有用的任务。这也意味着当你成长为一个更高级的程序员时，JavaScript在你手中的威力也在增长。

JavaScript允许你模仿其他语言的编程模式和惯用法。它也形成了自己的一些编程模式和惯用法。那些较为传统的服务器端编程语言具有的面向对象特性，JavaScript都有。

先来看一个用不同方法完成同样的任务的例子：启动和停止一个动画。如果你看不懂这些例子，别担心。我们在此使用的所有模式和技术都会在本书后面进行讲解。目前你可以把这一部分看作一个演示在JavaScript中用不同方法完成同一任务的实际例子。

如果你习惯于过程式的程序设计，那么可以这样做：

~~~javascript
/*使用函数来开始和结束动画*/
function startAnimation(){
    ...
}
    
function stopAnimation(){
    ...
}
~~~

这种做法很简单，但你无法创建可以保存状态并且具有一些仅对其内部状态进行操作的方法的动画对象。下面的代码定义了一个类，你可以用它创建这种对象：

~~~javascript
/*Anim Class*/
var Anim = function(){
    ...
};
    
Anim.prototype.start = function(){
    ...
};
Anim.prototype.stop = function(){
    ...
};   
    
/*USage*/
var myAnim = new Anim();
myAnim.start();
...
myAnim.stop();
~~~

上述代码定义了一个名为Anim的类，并把两个方法赋给该类的prototype属性。第3章将详细讲述这种技术。如果你更喜欢把类的定义封装在一条声明中，则可改用下面的代码：

~~~javascript
/*Anim class, with a slightly different syntax for declaring methods.*/
var Anim = function(){
    ...
};
    
Anim.prototype = {
    start:function(){
        ...
    },
    stop:function(){
        ...
    }
};
~~~

这在传统的面向对象程序员看来可能更眼熟一点，他们习惯于看到类的方法声明内嵌在类的声明之中。要是你以前用过这样的编程风格，可能想尝试一下下面的示例。同样，如果代码中有些地方你看不懂，不必为此而焦虑：

~~~javascript
/*Add a method to the Function object that can be used to declare methods.*/
Function.prototype.method = function(name,fn){
    this.prototype[name] = fn;
};

/*Anim class, with methods created using a convenience method.*/
var Anim = function(){
    ...
};
    
Anim.method('start',function(){
    ...
});
    
Anim.method('stop',function(){
    ...
});
~~~

`Function.prototype.method`用于为类添加新方法。它有两个参数。第一个是字符串，表示新方法的名称；第二个是用作新方法的函数。

你可以进一步修改`Function.prototype.method`，使其可被链式调用。这**只需要让它返回this值即可**（方法的链式调用技术将在第6章中讲述）：

~~~javascript
/*This version allows the calls to be chained.*/
Function.prototype.method = function(name,fn){
    this.prototype[name] = fn;
    return this;
}

/*Anim class, with methods created using a convenience method and chaining.*/
var Anim = function(){
    ...
};
Anim.
  method('start',function(){
    	...
  }).
  method('stop',function(){
        ...
  })
~~~

你已经见识了完成同一项任务的**5种不同方法**，它们的风格略有差异。基于自己的编程背景，你可能觉得其中的某种方法比别的方法更为合意。这是件好事：JavaScript允许你用最适合于手头项目的编程风格进行工作。不同的风格在代码篇幅、编码效率和执行性能方面各有其特点。本书的第一部分将讨论所有这些风格。

## 弱类型语言

在JavaScript中，定义变量时不必声明其类型。但这并不意味着变量没有类型。一个变量可以属于几种类型之一，这取决于其包含的数据。JavaScript中有3种原始类型：**布尔型、数值型和字符串**类型（**不区分整数和浮点数是Javascript与大多数其他主流语言的一个不同之处**）。此外，还有**对象类型**和包含可执行代码的**函数类型**，前者是一种复合数据类型（数组是一种特殊的对象，它包含着一批值的有序集合）。最后，还有**空类型（null）和未定义类型（undefined）**这两种数据类型。**原始数据类型按值传送，而其他数据类型则按引用传送**。如果不了解这一点的话，你很可能会碰到一些意想不到的问题。

与其他弱类型语言一样，Javascript中的变量可以根据所赋的值**改变类型**。**原始类型之间也可以进行类型转换**。`toString`方法可以把数值或布尔值转变为字符串。`parseFloat`和`parselnt`函数可以**把字符串转变为数值**。**双重“非”操作可以把字符串或数值转变为布尔值**：

~~~javascript
var bool= !!num;
~~~

弱类型的变量带来了极大的灵活性。因为JavaScript会根据需要进行类型转换，所以一般说来，你不用为类型错误操心。

## 函数是一等对象

在JavaScript中，函数是一等对象。它们可以存储在变量中，可以作为参数传给其他函数，可以作为返回值从其他函数传出，还可以在运行时进行构造。在与函数打交道时，这些特性带来了极大的灵活性和极强的表达能力。在阅读本书时你会体会到，这正是用以构建传统的面向对象框架的基础。

可以用`function(){...}`这样的语法创建匿名函数。它们没有函数名，但可以被赋给变量。

下面是一个匿名函数的示例：

~~~javascript
/*An anonymous function, executed immediately.*/
(function(){
    var foo = 10;
    var bar = 2;
    alert(foo * bar)
})()
~~~

这个函数在定义之后便立即执行，甚至不用赋给一个变量。出现在函数声明之后的一对括号立即对函数进行了调用。括号中空无一物，但也并不是非得如此：

~~~javascript
/*An anonymous function with arguments.*/
(function(foo,bar){
    alert(foo * bar)
})(10,2);
~~~

这个匿名函数与前一个等价，只不过变量没有在函数内部用var声明，而是作为参数从外部传入而已。这个函数也可以返回一个值。这个返回值可以被赋给一个变量：

~~~javascript
/*An anonymous function that returns a value.*/
var baz = (function(foo,bar){
    alert(foo * bar)
})(10,2);

//baz will equal 20.
~~~

匿名函数最有趣的用途是用来创建闭包。闭包（closure）是一个受到保护的变量空间，由内嵌函数生成。

JavaScript具有函数级的作用域。这意味着定义在函数内部的变量在函数外部不能被访问。JavaScript的作用域又是**词法性质**的（lexically scoped），这意味着**函数运行在定义它的作用域中，而不是在调用它的作用域中**。把这两个因素结合起来，就能通过把变量包裹在匿名函数中而对其加以保护。你可以这样创建类的私用（private）变量：

~~~javascript
/*An anonymous function used as a closure.*/
var baz;
(function(){
    var foo = 10;
    bar bar = 2;
    baz = function(){
        return foo * bar;
    }
})()

baz();	
//baz can access foo and bar, even though it is executed outside of the anonymous function.
~~~

变量foo和bar定义在匿名函数中。因为函数baz定义在这个闭包中，所以它能访问这两个变量，即使是在该闭包执行结束后。这是一个复杂的话题，本书中会多次涉及。在第3章讨论封装的时候将对这种技术详加讲解。

## 对象的易变性

在JavaScript中，一切都是对象（除了那三种原始数据类型。即便是这些类型，在必要的时候也会被自动包装为对象），而且所有对象都是易变的（mutable），这意味着你能使用一些在大多数别的语言中不允许的技术，例如为函数添加属性：

~~~javascript
function displayError(message){
    displayError.numTimesExecuted++;
    alert(message);
};

displayError.numTimesExecuted = 0;
~~~

这也意味着你可以对先前定义的类和实例化的对象进行修改：

~~~javascript
/*Class Person.*/
function Person(name,age){
    this.name = name;
    this.age = age;
}

Person.prototype = {
    getName:function(){
        return this.name;
    },
    getAge:function(){
        return this.age;
    }
}

/*Instantiate the class.*/
var alice = new Person('Alice',25);
var bill = new Person('Bill',30);

/*Modify the class.*/
Person.prototype.getGreeting = function(){
    return 'Hi' + this.getName() + '!';
};

/*Modify a specific instance.*/
alice.displayGreeting = function(){
    alert(this.getGreeting());
}
~~~

在这个例子中，类的getGreeting方法是在已经创建了类的两个实例之后才添加的，但这两个实例仍然能获得这个方法，其原因在于prototype对象的工作机制。对象alice还得到了displayGreeting方法，而别的实例却没有。

与对象的易变性相关的还有内省（introspection）的概念。你可以在运行时检查对象所具有的属性和方法，还可以使用这种信息动态实例化类和执行其方法（这种技术称为反射（reflection），甚至不需要在开发时知道它们的名称。这些技术在动态脚本编程中发挥着重要作用，而静态语言例如C++）则缺乏这样的特性。

本书中大多数用来模仿传统的面向对象特性的技术都依赖于对象的易变性和反射。如果你习惯使用C+或Java这类语言，可能会觉得这很奇怪，因为在那些语言中，不能对已经实例化的对象进行扩展，也不能对已经定义好的类进行修改。而在JavaScript中，任何东西都可以在运行时修改。这是一个强有力的工具，许多在别的语言中无法办到的事都能借助于它而办到。当然，这也有其不利之处。你可以定义一个具有一套方法的类，却不能肯定这些方法在以后总是完好如初。

这是JavaScript中很少进行类型检查的原因之一。这个问题将在第2章讲述鸭式辨型（duck typing）和接口检查时进行探讨。

## 继承

继承在JavaScript中不像在别的面向对象语言中那样简单。Javascript使用的是基于对象的（原型式（prototypal））继承，它可以用来模仿基于类的（类式（classical）继承。这两种范型本书都会讲述，编写代码时用哪一种都行，根据手头任务的实际情况，有时其中的某种会更适合一些。它们在性能上也有不同的表现，这也是在进行选择时需要考虑的重要因素。这个复杂的话题将在第4章中进行探讨。

## JavaScript中的设计模式

1995年，GoF合作出版了一本名为《设计模式》的书。这本书整理记录了对象间相互作用的各种方式，并针对不同类型的对象创造了一套通用术语。用以创建这些不同类型的对象的套路被称为设计模式（design pattern），出于通用性的考虑，书中使用了一种在一定程度上独立于语言的方式来描述这些模式。本书就是专门讨论这些模式在JavaScript中的应用的。

JavaScript强大的表现力赋予了程序员在运用设计模式编写代码时极大的创造性。在JavaScript中**使用设计模式**主要有如下3原因。

（1）可维护性。设计模式有助于降低模块间的耦合程度。这使对代码进行重构和换用不同的模块变得更容易，也使程序员在大型团队中的工作以及与其他程序员的合作变得更容易。

（2）沟通。设计模式为处理不同类型的对象提供了一套通用的术语。程序员因此可以更简明地描述自己的系统的工作方式。你不用进行冗长的说明，往往这样一句话就足够了：“它使用了工厂模式”。每个模式都有自己的名称，这意味着你可以在较高层面上对其进行讨论，而不必涉足过多的细节。

（3）性能。本书讲述的某些模式是起优化作用的模式。它们可以大幅提高程序的运行速度，并减少需要传送到客户端的代码量。这方面最重要的例子是享元模式（第13章）和代理模式（第14章）。

你也可能出于如下两个理由而**不使用设计模式**。

（1）复杂性。获得可维护性往往要付出代价，那就是代码可能会变得更加复杂、更难被程序设计新手理解。

（2）性能。尽管某些模式能提升性能，但多数模式对代码的性能都有所拖累。这种拖累可能微不足道，也可能完全不能接受，这取决于项目的具体需求。

实现设计模式比较容易，而懂得应该在什么时候使用什么模式则较为困难。未搞懂设计模式的用途就盲目套用，是一种不安全的做法。你应该尽量保证所选用的模式就是最恰当的那种，并且不要过度牺牲性能。

## 小结

JavaScript的丰富表现力是其力量之源。即使这种语言缺少一些有用的内置特性，拜其灵活性所赐，你也能自己加入这些特性。完成一项任务可以有多种方式，你可以根据自己的技术背景和喜好选择编写代码的方式。

JavaScript是弱类型语言。程序员在定义变量时并不指定其类型。函数是一等对象，并且可以动态创建，因此你可以创建闭包。所有对象和类都是易变的，可以在运行时修改。可供使用的继承范型有两种，即原型式继承和类式继承，它们各有其优缺点。

JavaScript中的设计模式颇有助益，但其不当应用也会产生负面效果。在JavaScript这类轻灵的语言中，过度复杂的架构会很快把应用程序拖入泥沼。你使用的编程风格和选择的设计模式应该与所要完成的具体工作相称。

# 第2章：接口

[什么是接口与API接口](https://zhuanlan.zhihu.com/p/93367446)

接口是面向对象JavaScript程序员的工具箱中最有用的工具之一。GoF在《设计模式》一书中提出的可重用面向对象设计的第一条原则中就说道：“针对接口而不是实现编程”，这个概念的基本性由此可见一斑。

问题在于，JavaScript中没有内置的创建或实现接口的方法。它也没有内置的方法可以用于判断一个对象是否实现了与另一个对象相同的一套方法，这使对象很难互换使用。好在JavaScript有着出色的灵活性，因此添加这些特性并非难事。

本章将考察其他面向对象的语言中实现接口的方法，并对它们在这方面最突出的特性进行模仿。我们先讨论在JavaScript中实现接口的各种方法，最后设计出一个可重用的类，用于检查对象是否具有必要的方法。

## 什么是接口

接口提供了一种用以说明一个对象应该具有哪些方法的手段。尽管它可以表明（或至少是暗示）这些方法的语义，但它并不规定这些方法应该如何实现。例如，如果一个接口包含有一个名为setName的方法，那么你有理由认为这个方法的实现应该具有一个字符串参数，并且会把这个参数赋给一个name变量。

有了这个工具，你就能按对象提供的特性对它们进行分组。例如，即使一批对象彼此存在着极大的差异，只要它们都实现了Comparable接口，那么在object.compare（anotherobject）方法中就可以互换使用这些对象。你还可以使用接口开发不同的类之间的共同性。如果把原本要求以个特定的类为参数的函数改为要求以一个特定的接口为参数的函数，那么任何实现了该接口的对象都可以作为参数传递给它。这样一来，彼此不相关的对象也可以被同等对待。

### 接口之利

在面向对象的JavaScript中，接口有些什么作用呢？既定的一批接口具有自我描述性，并能促进代码的重用。接口可以告诉程序员一个类实现了哪些方法，从而帮助其使用这个类。如果你熟悉一个特定的接口，那么就已经知道如何使用任何实现了它的类，从而更有可能重用现有的类。

接口还有助于稳定不同的类之间的通信方式。如果事先知道了接口，你就能减少在集成两个对象的过程中出现的问题。借助于它，你可以事先就说明你希望一个类具有哪些特性和操作。一个程序员可以针对所需要的类定义一个接口，并把它转交给另一个程序员。第二个程序员可以随心所欲地编写自己的代码，只要他定义的类实现了那个接口就行。这在大型项目中尤其有用。

测试和调试因此也能变得更轻松。在JavaScript这种弱类型语言中，类型不匹配错误很难跟踪。

使用接口可以让这种错误的查找变得更容易一点，因为此时如果一个对象不像所要求的类型，或者没有实现必要的方法，那么你会得到包含有用信息的明确的错误提示。这样一来，逻辑错误可以被限制在方法自身，而不是在对象的构成之中。接口还能让代码变得更稳固，因为对接口的任何改变在所有实现它的类中都必须体现出来。如果接口添加了一个操作，而某个实现它的类并没有相应地添加这个操作，那么你肯定会立即见到一个错误。

### 接口之弊

接口并非没有缺点。JavaScript是一种具有极强表现力的语言，这主要得益于其弱类型的特点。
而接口的使用则在一定程度上强化了类型的作用。这降低了语言的灵活性。

JavaScript并没有提供对接口的内置支持，而试图模仿其他语言内置的功能总会有一些风险。JavaScript中没有Interface这个关键词，因此，不管你用什么方法实现接口，它总是与C++和Java这些语言中所用的方法大相径庭，这加大了初涉JavaScript时所遇到的困难。

JavaScript中任何实现接口的方法都会对性能造成一些影响，在某种程度上这得归咎于额外的方法调用的开销。我们的实现方法中使用了两个for循环来遍历所需要的每一个接口中的每一个方法。对于大型接口和需要实现许多不同接口的对象，这种检查可能要花点时间，从而对性能造成负面影响。如果你在乎这个问题，那么可以在开发完成之后剔除这种代码，或者将其执行与一个调试标志关联起来，这样在运营环境中它就不会执行。但要注意不要过早进行优化处理。Firebug这类性能分析器可以帮助你判断是否真有必要剔除接口代码。

接口使用中的最大问题在于，无法强迫其他程序员遵守你定义的接口。在其他语言中，接口的概念是内置的，如果某人定义了实现一个接口的类，那么编译器会确保该类的确实现了这个接口。而在JavaScript中则必须用手工的办法保证某个类实现了一个接口。编码规范和辅助类可以提供一些帮助，但无法彻底根除这个问题。如果项目的其他程序员不认真对待接口，那么这些接口的使用是无法得到强制性保证的。除非项目的所有人都同意使用接口并对其进行检查，否则接口的很多价值都无从体现。

## 其他面向对象语言处理接口的方式

这里先概览一下三种广泛使用的面向对象语言处理接口的方式。你会发现它们的办法大体相似。稍后在2.5节中创建Interface类时，我们会尽量模仿它们的功能。

Java使用接口的方式是面向对象语言中比较典型的，所以我们先从Java开始。下面是java.io包中的一个接口：

![](读书笔记：JavaScript设计模式(国外)/03.png)

它列出了一个类应该实现的一批方法，包括方法的参数和可能会抛出的异常。每一行都像是一个方法声明，只不过是以一个分号而不是一对大括号结尾的。

创建一个实现这个接口的类需要使用关键字implements：

![](读书笔记：JavaScript设计模式(国外)/04.png)

