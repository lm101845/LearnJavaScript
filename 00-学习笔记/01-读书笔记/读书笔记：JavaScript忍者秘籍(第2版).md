---
title: 读书笔记：JavaScript忍者秘籍(第2版)
date: 2020-09-21 16:30:00
tags: 读书笔记
categories: 前端理论
---

(注1：这本书是我加入的一个前端微信群里的人推荐的，我下载完，准备大体看一下，就当查漏补缺吧。)

(注2：这本书和《你不知道的JavaScript-上卷》结合着看比较好)

(注3：随着时间的推移，我慢慢的发觉自己看的这么多书里面的内容开始有大段大段的重复和交集了，这也意味着自己对于JavaScript的学习在广度上应该是没有什么大问题了，现在要做的就是往下挖，提高自己的钻研深度以及提高代码量了。以后在实际写代码的过程中遇到了问题再回过头来看看这些书，可以达到相得益彰的效果了。)

(注4：这本书和我以前看的那些书和视频里面的知识点重合度几乎100%，也就是说里面的内容我几乎都学过，以后可以当成JavaScript知识点的复习书，现在我还没时间去看，现在肯定是先看《你不知道的JavaScript》收益更高一些。)

(注5：现在是2020年10月27日，感觉自己原生的JavaScript基础还是不行啊，这本书挺好的，好好的把这本书再看一遍，就算复习一遍之前学的JavaScript了。)

# 内容提要

JavaScript语言非常重要，相关的技术图书也很多，但至今市面没有一本对JavaScript语言的最重要部分（函数、闭包和原型）进行深入、全面介绍的图书，也没有一本讲述跨浏览器代码编写的图书。而本书弥补了这一空缺，是由JQuery库创始人编写的一本深入剖析JavaScript语言的书。

本书共分4个部分，从不同层次讲述了逐步成为JavaScript高手所需的知识。本书从JavaScript语言及最重要的特性谈起，由浅入深地探讨了函数、作用域、闭包、生成器函数、对象、数组、模块化、JavaScript与Web页面的交互以及事件等主题，引导读者更加深入地了解JavaScript的方方面面，充分展示了JavaScript语言的各种特性。本书结合ECMAScript6和7的相关概念，涵盖了流行的JavaScript框架所使用的技术。

本书适合具备一定JavaScript基础知识的读者阅读，也适合从事程序设计工作并想要深入探索JavaScript语言的读者阅读。

# 序

自2008年我编写《JavaScript忍者秘籍》起，到现在JavaScript的世界发生了翻天覆地的变化。我们现在编写的JavaScript，虽然大部分仍然是基于浏览器，但是几乎快认不出来了。

由于功能全面、跨平台的特性，JavaScript的流行度呈爆发式增长。Nodejs是一个强大的平台，已基于Nodejs开发了无数的生产应用程序。开发人员实际上是在使用一种语言JavaScript编写应用程序以及同时可运行于浏览器端、服务器端甚至移动设备上的本地应用。

现在所需的JavaScript知识，比以前任何时候都更为重要。对JavaScript这门语言有一个基本的理解，并且了解最佳编程方式，有助于创建几乎可在任何平台运行的应用程序，几乎没有其他语言可以做到这一点。

与以往JavaScript增长的时代不同，**平台不兼容**的情况没有得到改善。你常常会垂延于使用最基本的浏览器新特性，但是过时的浏览器却占领了太多的市场份额。我们已经进入了一个和谐的时间，大多数用户都在快速更新最符合标准的平台。浏览器厂商甚至推出专门针对开发人员的特性，希望这能使他们的生活更加简单。

浏览器目前提供给我们的工具以及开源社区，是过去实践之后的光明。我们现在有大量的可供选择的测试框架，有持续集成测试的能力，可以生成代码覆盖报告，在真正的全球移动设备上做性能测试，甚至可在任何平台上自动加载虚拟浏览器进行测试。

这本书的第1版极大地受益于Bear Bibeault的开发洞察力。这个版本得到Josip Maras大量的帮助，他研究ECMAScript 6和7的相关概念，深入了解测试最佳实践，了解流行的JavaScript框架所使用的技术。

我们编写JavaScript的方式发生了巨大的变化，这很难阐述。好在这本书可以帮助你了解当前的最佳实践。不仅如此，本书还会帮助你改善思维方式，如何将开发实践作为一个整体，以确保为未来编写JavaScript。

# 路线图

本书通过4个部分，让你从“学徒”晋升为“忍者”。

第1部分介绍我们后续学习的主题和所需要的工具。

* 第1章介绍JavaScript语言及最重要的特性，推荐目前我们开发应用时需要遵循的最佳实践，包括测试和性能分析。
* 因为我们对JavaScript的研究是基于浏览器上下文，因此在第2章中，我们介绍客户端Web应用的生命周期，这有助于我们理解在开发Web应用程序时JavaScript所扮演的角色。

第2部分重点关注JavaScript的核心支柱之--函数。我们将研究为什么函数如此重要，函数之间的区别，以及定义和调用函数的细节内容。我们还将特别关注一个新的函数类型-生成器函数，它在处理异步代码时尤为有效。

* 第3章从彻底检查JavaScript函数的定义开始涉足基础语言，也许你会感到吃惊。预期中可能是把对象作为重点，但是，让我们充分理解函数、JavaScript函数式语言，从普通的JavaScript程序员升级为JavaScript“忍者”！
* 在第4章中，我们继续研究函数，深入研究函数调用的机制，以及隐式函数参数的来龙去脉。
* 关于函数的内容还没有结束，在第5章我们把讨论推向更高的一个层级，研究两个密切相关的概念-作用域和闭包。闭包是函数式编程中的关键概念，闭包允许更细粒度地控制程序中声明和创建的对象作用域范围。控制对象的作用域范围是“忍者”编写代码的关键因素。即使不阅读后续的章节（但我们希望大家不要停下来），编程水平也会比刚开始学习时提高很多。
* 在第6章中，我们通过一种全新的函数类型（生成器函数）和一个新的对象类型（promise）帮助我们处理异步代码，最后结束对函数的研究。我们还展示了如何结合generator与promise，优雅地处理异步代码。

第3部分研究JavaScript的第二支柱--对象。我们将彻底地探索JavaScript中的面向对象，研究如何保护对对象的访问，如何处理集合和正则表达式。

* 第7章阐述对象，彻底了解JavaScript中面向对象是如何工作的。此外，我们还将引入一个新的JavaScript关键字：class，其背后概念可能与你所期望的有所不同。
* 第8章继续探索对象，我们将学习使用多种不同的技术保护对对象的访问。
* 在第9章中，我们将特别关注JavaScript中几种不同类型的集合。数组，从JavaScript诞生起就是JavaScript的一部分，map和set是最近新加入JavaScript的集合类型。
* 第10章着重介绍正则表达式，正则表达式是经常被忽略的一项语言特性，但正确使用正则表达式，可以减少很多代码量。我们将学习如何构建和使用正则表达式，以及如何使用正则表达式及其相关方法，优雅地解决一些重复出现的问题。
* 在第11章中，我们将学习使用不同技术实现代码模块化：更小、相对松耦合的代码片段，以及改善代码的机构和组织方式。

最后，第4部分研究JavaScript与Web页面的交互以及浏览器如何处理事件，最后结束本书。在结束之前的最后一个重要话题是跨浏览器开发。

* 第12章研究如何通过DOMAPI动态修改页面，如何处理元素属性、样式，以及一些重要的性能注意事项。
* 第13章讨论JavaScript的单线程执行模型的重要性，以及单线程执行模型对事件循环的影响。我们还将学习间隔定时器的工作原理，以及如何使用它们提高Web应用程序的性能。
* 第14章检查开发时主要关心的5项跨浏览器问题：浏览器缺陷、缺陷修复、外部代码、功能缺失和回归。讨论诸如特性模拟和对象检测等方法，有助于跨浏览器开发的挑战。

# 第一部分：热身

本书的第1部分将为你奠定JavaScript“忍者”修炼的基础。在第1章中，我们将一览JavaScript的现状，并探讨几种能够运行JavaScript代码的环境。作为JavaScript的“发祥地”，浏览器将是我们的重点关注对象。此外，我们还将讨论一些JavaScript应用开发中的最佳实践。

由于我们对JavaScript的探索限定在浏览器中，因此我们在第2章中介绍了客户端网络应用的生命周期以及JavaScript代码的执行过程与该生命周期的对应关系。

当你读完这部分之后，就可以开始JavaScript“忍者”的修炼了。

# 第1章：无处不在的JavaScript

![](读书笔记：JavaScript忍者秘籍(第2版)/01.png)

我们先来聊聊Bob，2000年年初，在花了几年时间学习C++桌面应用开发之后，新晋程序员Bob从学校毕业，奔向了软件开发的广阔天地。那个时候，互联网的跨越式发展才刚刚开始。每个公司都想成为下一个亚马逊。有鉴于此，他做的第一件事就是学习网络开发最初他用PHP动态生成网页，并在其中穿插JavaScript代码来实现复杂的功能，例如表单验证，甚至是动态的页内计时器。时光如梭，几年之后，智能手机已然成了气候。

预见到一个庞大的新兴市场即将形成，Bob决定先行一步，开始学习使用Objective-C和Java来创建运行于iOs和Android上的移动端应用。

几年来，Bob开发了很多成功的应用软件，并且都需要维护和扩展。遗憾的是，**日日辗转于不同的编程语言和应用框架之间，可怜的Bob已经筋疲力尽了**。

现在我们来谈一下Ann。两年前，Ann在获得软件开发相关的学位后毕业。她的专业方向偏向于网络以及基于云的应用开发。她已经开发出了一些中等规模的网络应用。

这些应用基于现代的模型-视图一控制器（Model-View-Controller，MVC）框架，并且还有相应的移动应用供iOS和Android用户使用。她还开发了一款能够同时在Linux Windows和OSX上运行的桌面应用，甚至着手将其改为完全基于云的无服务器的版本。

最重要的是，她所做的所有事情都是通过JavaScript来实现的。

真是一件了不起的事情。Bob花了10年用5种语言才完成的事情，Ann只需要2年以及1种语言就完成了。纵观整个计算机的发展史，还没有哪个特定的知识集合能够如此容易地通行于不同的领域，并发挥作用。

1995年的一项10天内仓促完成的项目，现在却成为了世界上使用最广泛的编程语言之一。JavaScript现在确确实实是无处不在了，这得归功于更强大的JavaScript引擎和一众框架的出现，如Node，Apache Cordova，Ionic和Electron，是它们让这门粗陋的语言冲出了网页的牢笼，飞向了更广阔的空间。此外，如同HTML一样，这门语言本身也正处于期待已久的进化当中，从而被打造成更加适合现代应用开发的语言。

在本书中，我们首先要保证让你了解所有你需要了解的关于JavaScript的内容，这样无论你的情况与Ann还是Bob更为接近，都能够开发各种类型的应用。

![](读书笔记：JavaScript忍者秘籍(第2版)/02.png)

## “理解"JavaScript语言

随着职业生涯的发展，许多有着与Bob和Ann类似经历的JavaScript程序员，都到了在工作中运用构成这门语言大部分的元素的阶段。但实际上，很多时候这些技能的运用都处于相当初级的层次。我们对此做出的猜测是，由于JavaScript（采用类似于C语言的语法）有着与其他得到广泛使用的类C语言（比如C#和Java）相近的皮相，从而给人留下了与这些语言相似的印象。

人们总是觉得他们对C#或者Java的了解，能为他们理解JavaScript的工作原理打下坚实的基础。然而这是一个陷阱。与其他主流语言相比，JavaScript函数式语言的血统更多一些。Javascript中的一些概念从根本上不同于其他的语言。

这些根本性的差异包括以下内容。

* **函数是一等公民**（一级对象）——在JavaScript中，函数与其他对象共存，并且能够像任何其他对象一样地使用。函数可以通过字面量创建，可以赋值给变量，可以作为函数参数进行传递，甚至可以作为返回值从函数中返回。在第3章中我们将花费大量篇幅解释函数，探索它作为第一类对象在编写代码中的好处。
* 函数闭包——大部分人对闭包都缺乏理解，然而它却从根本上例证了函数之于JavaScript的重要性。尽管就目前而言，了解当函数主动维护了在函数内使用的外部的变量，则该函数为一个闭包就已经足够。现在还没看到闭包的好处也不要紧，第5章中我们会把它搞得一清二楚。除了闭包以外，在第3章和第4章中我们也会深入探讨函数的方方面面，第5章中还会讨论标识符作用域。
* 作用城——直到最近，JavaScript都还没有（类似C语言中的）块级作用域下的变量(ES6里有了)，取而代之则只能依赖函数级别的变量和全局变量。
* 基于原型的面向对象——不同于其他主流的面向对象语言（例如C#、Java，Ruby）使用基于类的面向对象，JavaScript使用基于原型的面向对象。很多开发者是从基于类的面向对象语言（例如Java）转而开发JavaScript，他们试图像开发Java一样开发JavaScript。然而由于某些原因，他们会因为结果与预期不同而感到出乎意料。这种情况就是我们要深入理解原型的原因，我们要知道基于原型的面向对象如何工作，以及怎样在JavaScript中实现面向对象。

对象、原型、函数和闭包的紧密结合组成了JavaScript。理解这些概念的密切联系能大大提高你的编程能力，为你开发各种类型的应用提供坚固的基础，无论你的应用是开发在网页上、桌面应用上、移动应用上还是服务器端。

除了这些基本概念，JavaScript的一些其他功能也能帮你书写优雅高效的代码。对于经验老道的Bob一样的开发者来说，这些部分特性在其他语言中也出现过，例如Java和C++。我们会特别聚焦于以下特性。

* 生成器，一种可以基于一次请求生成多次值的函数，在不同请求之间也能挂起执行。
* Promise，让我们更好地控制异步代码。
* 代理，让我们控制对特定对象的访问。
* 高级数组方法，书写更优雅的数组处理函数。
* Map，用于创建字典集合：Set，处理仅包含不重复项目的集合。
* 正则表达式，简化用代码书写起来很复杂的逻辑。
* 模块，把代码划分为较小的可以自包含的片段，使项目更易于管理。

深入理解Javascript的基础知识，以及学习如何最大程度地利用JavaScript的高级特性，能够让你的代码编写水平提升到一个更高的水平。磨炼代码技能、并将这些概念和特性连贯起来也能让你对JavaScript的理解更上一层楼，从而为你编写各种类型的Javscript应用赋予强大的创造力。

### JavaScript是如何发展的

ECMAScript语言标准化委员会已经完成了ES7/ES2016版本Javascript的制定。对于JavaScript（至少相对于ES6而言）ES7是个较小的升级。这是因为委员会的未来目标是每年都能为JavaScript更新较小的改动。

本书中将彻底探索ES6以及ES7的新特性，例如用于处理异步代码的async函数（第6章中会讨论）。

![](读书笔记：JavaScript忍者秘籍(第2版)/03.png)

尽管每年都能增量发布语言新特性是个利好消息，但这并不代表Web开发者能在标准一发布就能立即使用新特性。由于JavaScript代码必须由JavaScript引擎来执行，所以我们必须耐心等待心爱的引擎更新，从而能支持那些令人激动的新特性。

尽管JavaScript引擎开发者也在力求始终保持对最新特性的支持，但开发者还是很可能陷入想使用新特性却还没被支持的困境。

好在你还能通过下列方式https://kangax.github.io/compat-table/es6/、http://kangax.github.io/compat-table/es2016plus/以及https://kangax.github.io/compat-table/esnext进行查看，由此保持对浏览器支持状态的了解。

### 如今的转换编译器已经能让我们体验未来的JavaScript

由于浏览器版本的飞速发布，我们通常不需要等待多久就能等到对JavaScript的支持。但当我们想利用JavaScript的最新特性时，也往往会被残酷的现实绑架：用户依然在使用老旧的浏览器。这时该怎么办？

解决这个问题的方式之一是使用转换编译器transpilers（即“转换器+编译器”，"transformation + compiling"），这类工具能够把最前沿的JavaScript代码转换为等价的（如果不能实现，则使用相似的）能在当前浏览器中运行的代码。

最流行的转换编译器是Traceur和Babel。使用如下教程可以很容易地配置它们：https://github.com/googLe/traceur-compiler/wiki/Getting-stanted或http://abeljs.o/docs/setup。

本书中，我们会主要集中讨论浏览器中的JavaScript代码。为了有效利用浏览器平台，你需要多多实践，学习浏览器的内部原理。让我们开始吧！

## 理解浏览器

现如今，JavaScript应用能在很多环境中执行。但是，Java Script最初的运行环境是浏览器环境，而其他运行环境也是借鉴于浏览器环境。本书将重点专注浏览器环境。浏览器提供了多种概念和API让我们来探索，如图1.1所示。

我们将集中讨论如下概念。

* 文档对象模型（DOM）——DOM是Web应用的结构化的UI表现形式，至少最初由Web应用的HTML代码构成。为开发大型应用，你不仅需要深入理解JavaScript的核心机制，还要学习DOM是如何构成的（第2章）以及如何书写有效的DOM操作代码（第12章）。你将学会如何创造高级的、动态的UI。

![](读书笔记：JavaScript忍者秘籍(第2版)/04.png)

* 事件——大部分JavaScript应用都是事件驱动的应用，这表示大部分代码执行在对某个特殊事件响应的上下文中。这样的事件例如网络事件、计时器、用户生成事件例如点击、鼠标移动、键盘按压事件等。因此，第13章中我们将完整探索事件机制。我们特殊关注计时器，计时器通常像个谜团一样，但它能帮我们处理复杂编码任务：例如长期执行的计算和流畅的动画。

* 浏览器API——帮助我们与世界交互，浏览器提供获取设备的信息、存储本地数据或与远程浏览器交互的API。本书我们会探索其中的一些API。完善编程技能并对浏览器提供的API有深入理解能让你走的更远。但是迟早，你将会遇到浏览器的不一致性等问题。在完美的世界中，所有浏览器都应该没有缺陷，应该都能以一致的方式支持Web标准。然而我们的现实世界并不完美。

近来浏览器的质量已经大大提高了，但我们仍然需要面对一些缺陷：例如缺失的API，某个浏览器的奇怪问题。针对浏览器的这些问题开发出一种易于理解的机制，并搞清楚它们的差异和宽松模式，这与精通JavaScript几乎同等重要。

当我们开发浏览器应用或JavaScript库时，选择支持哪个路蓝旗是很值得深思熟虑的。我们希望全部支持，但受限于开发测试资源要求或其他要求。因此在第14章中，我们将彻底地探索跨浏览器开发的策略。

开发高效的跨浏览器代码显著依赖于开发者的经验和技巧。本书旨在提高开发者技能水平，所以让我们通过当前的最佳实践来开始学习吧。

## 使用当前的最佳实践

精通JavaScript语言和掌握跨浏览器代码问题对于专家级Web应用开发者来说是重要课题，但它们不是整个蓝图。若想进入整个联盟，你还需要展示出一些已经被大量先前开发者所证明能够开发出高质量代码的特质。这些特质被称为最佳实践，所以你除了精通JavaScript语言以外，还需要具有以下特质：

* 调试技巧；
* 测试；
* 性能分析。

在编程中把这些技能有效结合在一起非常重要，本书会使用它们。接下来看看这些技巧。

### 调试

以前，调试JavaScript代码意味着使用alert来验证变量的值。好在，由于Firefox浏览器的开发者扩展Firebug的流行，所以调试JavaScript代码的能力大大增强了。所有主流浏览器的类似工具也都被开发出来：

* Firebug——开发者扩展工具Firefox的流行成为了调试工具的开端；
* Chrome DevTools——由Chrome团队开发，并应用在了Chrome和Opera浏览器中；
* Firefox开发者工具——包含在Firefox中的工具，由Firefox团队开发；
* F12开发者工具——Internet Explorer浏览器及微软Edge浏览器中包含的调试工具；
* WebKit检视器——Safari中包含的调试工具。

如你所见，主流浏览器都为开发者提供了调试Web应用程序的工具。使用alert来调试JavaScript代码的日子一去不复返了！所有这些工具都有着类似于Firebug最初引入的概念，故而它们都提供着相似的功能：探索DOM、调试JavaScript、编辑CSS样式和跟踪网络事件等。其中的每样工具都做得很棒。你既可以使用你自己选择的浏览器所提供的调试工具，也可以使用你发现缺陷时所用的浏览器调试工具。

除此之外，你也可以使用其中的几个工具，例如用Chrome开发者工具来调试其他类型的应用，例如Node.js应用（在附录B中，我们会向你介绍一些调试技术）。

### 测试

在本书中，我们会使用一些测试技术来确保示例代码按预期执行，同时这些测试技术也用于展示一般情况下如何测试代码。我们用于测试的主要工具是一个断言函数，其目的在于断定某个假设是真值还是假值。

该函数的一般形式如下所示：

~~~javascript
assert(condition,message);
~~~

第一个参数是一个应为真值的条件，第二个参数是当断言为假时所展示的一句话。例如：

~~~javascript
assert(a === 1,"Disaster!a is not 1!");
~~~

如果变量的值不等于1，则断言失败，然后那段有点儿戏剧性的消息就会被展示出来。

> 断言函数并不是JavaScript的标准特性，所以我们在附录B中会展示它的实现。

### 性能分析

分析性能是另一个重要实践。尽管JavaScript引擎已经让Javascript以惊人的效率提升，然而我们依然没有理由书写粗糙低效的代码。

我们会使用如下的代码来收集性能信息：

![](读书笔记：JavaScript忍者秘籍(第2版)/05.png)

这段代码中，我们把要被测量的代码放在两个计时器调用之间，分别是内置console对象上的time和timeEnd方法。

在操作开始执行之前，调用console.time启动一个命名计时器（本例中计时器名为My operation），然后在特定的循环次数下运行代码（本例中运行maxCount次）。由于一次操作执行太快很难测量，所以我们要多次运行代码从而取得一个能够测量的值。运行次数可以成百上千，甚至上万，其完全依赖于将被测量的代码性质。几次摸索后我们就能得到一个合理的值。

操作结束后则用相同的计时器名字调用console.timeEnd，随后浏览器就会输出从开始到当前的时间差。

把这种技术与前面所学到的最佳实践技术统一起来，你对JavaScript的开发能力就会大幅度提升。在浏览器提供的有限资源下，在浏览器能力和兼容性逐渐复杂的世界中开发应用，需要一套健壮和完整的技巧。

## 提高跨平台开发能力

Bob初入Web开发行业时，他会发现每个浏览器都有一套自己的脚本及UI样式的解释方式，并试图鼓吹他们的方式才是最好的方式，这使开发者们沮丧地咬牙切齿。

好在浏览器之争以HTML，CSS，DOM，API和JavaScript的标准化而结束，从而开发者能集中精力开发高效的跨浏览器JavaScript应用。确实，集中精力于把网站开发为应用催生了大量的想法、工具和从桌面应用到网站应用的技术。现如今，这些知识和工具的转换再次发生，想法、工具和源于客户端Web开发的技术逐渐渗入应用开发的其他领域。

对JavaScript基本原理和核心API的渗入理解能让你成为更全能的开发者。通过使用浏览器和Node.js（源自于浏览器的环境），你能够开发几乎你能想到的任何类型的应用。

* 桌面应用，通过使用如NW.js（http://nwjs.io/）或Electron（http://electron.atom.o/）的库可以开发桌面应用。这些技术通常通过包装浏览器使我们能用标准的HTML、CSS和JavaScript（我们可以完全依赖我们的核心JavaScript和浏览器知识来开发）以及一些额外的访问文件系统的能力来构建桌面应用。从而能够开发真正独立于平台的桌面应用，它和我们在Windows、Mac和Linux上见到的应用看起来一样。
* 移动应用，使用类似Apache Cordova（https://cordova.apache.org/）的框架开发。与使用Web技术构建桌面应用一样，该应用框架也包装了浏览器，不过其中还包含一些额外的针对特定平台的API，从而让开发者能与移动平台交互。
* 使用Node.js开发服务器端应用和嵌入式应用，Node.js是源自于浏览器的环境，使用了很多类似浏览器的底层原理。例如，Node.js能执行JavaScript代码，并且也基于事件驱动。

Ann并不知道自己有多幸运（尽管Bob有个很棒的想法），无论她是否需要构建一个标准的桌面应用还是移动应用、服务器端应用或嵌入式应用都没问题-所有这些应用都共享同样的标准客户端Web应用底层原理。

只要理解了JavaScript工作的核心原理、理解了浏览器提供的核心API（例如事件，同样与Node.js提供的机制有很多共同点），她就能加速所有应用的开发。在这个过程中，你将变得更全能，知识和理解力也逐步增长，从而能够处理各种各样的问题。你将能够在云上通过使用JavaScript API构建无需依赖服务器的应用，例如使用类似AWS Lamda来部署、维护和控制你应用的云组件。

## 小结

* 客户端Web应用作为如今最流行的应用，其概念、工具和技术从仅开发客户端Web应用已经深入到其他应用领域。理解客户端Web应用的基础能帮助你开发一系列不同领域的应用。
* 为了提高开发技能，你需要深入理解JavaScript的核心机制和浏览器所提供的架构。
* 本书集中探讨了核心JavaScript的机制，例如函数、函数闭包和原型，还有一些新的JavaScript特性，例如生成器、promise、代理、映射、集合和模块。
* JavaScript可以在大量的环境中执行，但所有环境的开端是我们将集中探讨的浏览器环境。
* 除了JavaScript以外，我们还将探索浏览器内部，例如DOM（网页UI的一种结构化表示方式）和事件，这是因为客户端Web应用是事件驱动的应用。

# 第2章：运行时的页面构建过程

![](读书笔记：JavaScript忍者秘籍(第2版)/06.png)

我们对JavaScript的探索从客户端Web应用开始，其代码也在浏览器提供的引擎上执行。为了打好后续对JavaScript语言和浏览器平台的学习基础，首先我们要理解Web应用的生命周期，尤其要理解JavaScript代码执行在生命周期的所有环节。

本章会完整探索客户端Web应用程序的生命周期，从页面请求开始，到用户不同种类的交互，最后至页面被关闭。首先我们来看看页面是如何从HTML代码建立的。然后我们将集中探讨JavaScript代码的执行，它给我们的页面提供了大量交互。最后我们会看看为了响应用户的动作，事件是如何被处理的。在这一些列过程中，我们将探索很多Web应用的基础概念，例如DOM（Web页面的一种结构化表示方式）和事件循环（它决定了应用如何处理事件）。让我们开始学习吧！

![](读书笔记：JavaScript忍者秘籍(第2版)/07.png)

## 生命周期概览

典型客户端Web应用的生命周期从用户在浏览器地址栏输入一串URL，或单击一个链接开始。例如，我们想去Google的主页查找一个术语。首先我们输入了URL，www.google.com，其过程如图2.1所示。

![](读书笔记：JavaScript忍者秘籍(第2版)/08.png)

从用户的角度来说，浏览器构建了发送至服务器（序号2）的请求，该服务器处理了请求（序号3）并形成了一个通常由HTML，CSS和JavaScript代码所组成的响应。

当浏览器接收了响应（序号4）时，我们的客户端应用开始了它的生命周期。由于客户端Web应用是图形用户界面（GUI）应用，其生命周期与其他的GUI应用相似（例如标准的桌面应用或移动应用），其执行步骤如下所示：

1. 页面构建-创建用户界面；
2. 事件处理-进入循环（序号5）从而等待事件（序号6）的发生，发生后调用事件处理器。

应用的生命周期随着用户关掉或离开页面（序号7）而结束。现在让我们一起看一个简单的示例程序：每当用户移动鼠标或单击页面就会显示一条消息。本章会始终使用这个示例，如清单2.1所示。

![](读书笔记：JavaScript忍者秘籍(第2版)/09.png)

清单2.1首先定义了两条CSS规则，即`#first`和`#second`，其指定了ID为first和second两个元素的文字颜色（从而使我们方便地区分两者），随后用first这个id定义了一个列表元素：

~~~css
<ul id="first"></ul>
~~~

然后定义一个addMessage函数，每当调用该函数都会创建一个新的列表项元素，为其设置文字内容，然后将其附加到一个现有的元素上：

~~~javascript
function addMessage(element,message){
    var messageElement = document.createElement("li");
    messageElement.textContent = message;
    element.appendChild(messageElement);
}
~~~

如下所示，通过使用内置的方法getElementByld来从文档中获取ID为first的元素，然后为该元素添加一条信息，用于告知页面正在加载中：

~~~javascript
var first = document.getElementById("first");
addMessage(first, "Page loading");
~~~

然后我们又定义了一个列表元素，这次给该列表赋予的ID属性为second：

~~~javascript
<ul id="second"></ul>
~~~

最后将这两个事件处理器附加到Web页面的body上。每当用户移动鼠标，鼠标移动事件处理器就会被执行，然后该处理器调用addMessage方法，为第二个列表元素加上一句话`"Event：mousemove"`。

~~~javascript
document.body.addEventListener("mousemove",function(){
    var second = document.getElementById ("second");
    addMessage (second, "Event: mousemove");
});
~~~

我们还注册了一个单击事件处理器，每当用户单击页面就会输出该消息`"Event：click"`，并添加至第二个列表元素中。

~~~javascript
document.body.addEventListener("click", function(){
	var second = document.getElementById ("second");
    addMessage(second,"Event: click");
});
~~~

该应用的运行结果和交互如图2.2所示。

我们还会用这个例子来展示Web应用生命周期阶段之间的不同之处。让我们从页面构建阶段开始讲起。

![](读书笔记：JavaScript忍者秘籍(第2版)/10.png)

## 页面构建阶段

当Web应用能被展示或交互之前，其页面必须根据服务器获取的响应（通常是HTML，CSS和JavaScript代码）来构建。页面构建阶段的目标是建立Web应用的UI，其主要包括两个步骤：

1.解析HTML代码并构建文档对象模型（DOM）；
2.执行JavaScript代码。

步骤1会在浏览器处理HTML节点的过程中执行，步骤二会在HTML解析到一种特殊节点——脚本节点（包含或引用JavaScript代码的节点）时执行。页面构建阶段中，这两个步骤会交替执行多次，如图2.3所示。

![](读书笔记：JavaScript忍者秘籍(第2版)/11.png)

### HTML解析和DOM构建

页面构建阶段始于浏览器接收 HTML 代码时，该阶段为浏览器构建页面 UI 的基础。通过解析收到的 HTML 代码，构建一个个 HTML 元素，构建 DOM。在这种对 HTML结构化表示的形式中，每个 HTML 元素都被当作一个节点。如图 2.4 所示，直到遇到第一个脚本元素，示例页面都在构建 DOM。

注意图 2.4 中的节点是如何组织的，除了第一个节点——html 根节点（序号 1）以外，所有节点都只有一个父节点。例如，head 节点（序号 2）父节点为 html 节点（序号1）。同时，一个节点可以有任意数量的子节点。例如，html 节点（序号 1）有两个孩子节点：head 节点（序号 2）和 body 节点。同一个元素的孩子节点被称作兄弟节点。（head节点和 body 节点是兄弟节点）尽管 DOM 是根据 HTML 来创建的，两者紧密联系，但需要强调的是，它们两者并不相同。你可以把 HTML 代码看作浏览器页面 UI 构建初始DOM 的蓝图。为了正确构建每个 DOM，浏览器还会修复它在蓝图中发现的问题。让我们看下面的示例，如图 2.5 所示。

![](读书笔记：JavaScript忍者秘籍(第2版)/12.png)

图2.5展示了一个简单的错误HTML代码示例，页面中的head元素中错误地包含了一个paragraph元素。head元素的一般用途是展示页面的总体信息，例如，页面标题、字符编码和外部样式脚本，而不是用于类似本例中的定义页面内容。故而这里出现了错误，浏览器静默修复错误，将段落元素放入了理应放置页面内容的body元素中，构造了正确的DOM（如图2.5右侧）。

![](读书笔记：JavaScript忍者秘籍(第2版)/13.png)

![](读书笔记：JavaScript忍者秘籍(第2版)/14.png)

在页面构建阶段，浏览器会遇到特殊类型的HTML元素——脚本元素，该元素用于包括JavaScript代码。每当解析到脚本元素时，浏览器就会停止从HTML构建DOM，并开始执行JavaScript代码。

### 执行JavaScript代码

所有包含在脚本元素中的JavaScript代码由浏览器的JavaScript引擎执行，例如，Firefox的Spidermonkey引擎，Chrome和Opera和v8引擎和Edge的（IE的）Chakra引擎。由于代码的主要目的是提供动态页面，故而浏览器通过全局对象提供了一个API使JavaScript引擎可以与之交互并改变页面内容。

#### JavaScript 中的全局对象

浏览器暴露给JavaScript引擎的主要全局对象是wndow对象，它代表了包含着一个页面的窗口。window对象是获取所有其他全局对象、全局变量（甚至包含用户定义对象）和浏览器API的访问途径。全局window对象最重要的属性是document，它代表了当前页面的DOM，通过使用这个对象，JavaScript代码就能在任何程度上改变DOM，包括修改或移除现存的节点，以及创建和插入新的节点。

让我们看看清单2.1中所示的代码片段：

~~~javascript
var first = document.getElementById("first");
~~~

这个示例中使用全局document对象来通过ID选择一个元素，然后将该元素赋值给变量first，随后我们就能在该元素上用JavaScript代码来对其作各种操作，例如改变其文字内容，修改其属性，动态创建和增加新孩子节点，甚至可以从DOM上将该元素移除。

![](读书笔记：JavaScript忍者秘籍(第2版)/15.png)

对浏览器提供的基本全局对象有了基本了解后，我们可以开始看看Javascript代码中两种不同类型的定义方式。

#### JavaScript 代码的不同类型

我们已能大致区分出两种不同类型的 JavaScript 代码：全局代码和函数代码。清单2.2 会帮你理解这两种类型代码的不同。

![](读书笔记：JavaScript忍者秘籍(第2版)/16.png)

这两类代码的主要不同是它们的位置：包含在函数内的代码叫作函数代码，而在所有函数以外的代码叫作全局代码。

这两种代码在执行中也有不同（随后你将能看到一些其他的不同，尤其在第5章中）。全局代码由JavaScript引擎（后续会作更多解释）以一种直接的方式自动执行，每当遇到这样的代码就一行接一行地执行。例如，在清单2.2中，定义在addMessage函数中的全局代码片段使用内置方法getElementByld来获取ID为first的元素，然后再调用addMessage函数，如图2.6所示，每当遇到这些代码就会一个个执行。

![](读书笔记：JavaScript忍者秘籍(第2版)/17.png)

反过来，若想执行函数代码，则必须被其他代码调用：既可以是全局代码（例如，由于全局代码的执行过程中执行了addMessage函数代码，所以addMessage函数得意被调用），也可以是其他函数，还可以由浏览器调用（后续会作更多解释）。

#### 在页面构建阶段执行 JavaScript 代码

当浏览器在页面构建阶段遇到了脚本节点，它会停止HTML到DOM的构建，转而开始执行JavaScript代码，也就是执行包含在脚本元素的全局JavaScript代码（以及由全局代码执行中调用的函数代码）。让我们看看清单2.1中的示例。

图2.7显示了在全局JavaScript代码被执行后DOM的状态。让我们仔细看看这个执行过程。首先定义了一个`addMessage`函数：

~~~javascript
function addMessage (element,message){
	var messageElement = document.createElement ("1i");
    messageElement.textContent = message;
    element.appendChild (messageElement);
}
~~~

然后通过全局document对象上的getElementByld方法从DOM上获取了一个元素：

~~~javascript
var first = document. getElementById ("first");
~~~

这段代码后紧跟着对函数addMessage的调用：

~~~javascript
addMessage (first, "Page loading")
~~~

这条代码创建了一个新的1i元素，然后修改了其中的文字内容，最后将其插入DOM中。

![](读书笔记：JavaScript忍者秘籍(第2版)/18.png)

这个例子中，JavaScript通过创建一个新元素并将其插入DOM节点修改了当前的DOM结构。一般来说，JavaScript代码能够在任何程度上修改DOM结构：它能创建新的接单或移除现有DOM节点。但它依然不能做某些事情，例如选择和修改还没被创建的节点。这就是为什么要把script元素放在页面底部的原因。如此一来，我们就不必担心是否某个HTML元素已经加载为DOM。

一旦JavaScript引擎执行到了脚本元素中（如图2.5中的addMessage函数返回）JavaScript代码的最后一行，浏览器就退出了JavaScript执行模式，并继将余下的HTML构建为DOM节点。在这期间，如果浏览器再次遇到脚本元素，那么从HTML到DOM的构建再次暂停，JavaScript运行环境开始执行余下的JavaScript代码。需要重点注意：JavaScript应用在此时依然会保持着全局状态。所有在某个JavaScript代码执行期间用户创建的全局变量都能正常地被其他脚本元素中的JavaScript代码所访问到。其原因在于全局window对象会存在于整个页面的生存期之间，在它上面存储着所有的JavaScript变量。只要还有没处理完的HTML元素和没执行完的JavaScript代码，下面两个步骤都会一直交替执行。

1.将HTML构建为DOM
2.执行JavaScript代码。

最后，当浏览器处理完所有HTML元素后，页面构建阶段就结束了。随后浏览器就会进入应用生命周期的第二部分：事件处理。

## 事件处理

客户端Web应用是一种GUI应用，也就是说这种应用会对不同类型的事件作响应，如鼠标移动、单击和键盘按压等。因此，在页面构建阶段执行的JavaScript代码，除了会影响全局应用状态和修改DOM外，还会注册事件监听器（或处理器）。这类监听器会在事件发生时，由浏览器调用执行。有了这些事件处理器，我们的应用也就有了交互能力。在详细探讨注册事件处理器之前，让我们先从头到尾看一遍事件处理器的总体思想。

### 事件处理器概览

浏览器执行环境的核心思想基于：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。想象一下在银行柜台前排队，每个人进入一支队伍等待叫号并“处理”。但JavaScript则只开启了一个营业柜台！每当轮到某个顾客时（某个事件），只能处理该立顾客。

你所需要的仅仅是一个在营业柜台（所有人都在这个柜台排队！）的职员为你处理工作，帮你订制全年的财务计划。当一个事件抵达后，浏览器需要执行相应的事件处理函数。这里不保证用户总会极富耐心地等待很长时间，直到下一个事件触发。所以，浏览器需要一种方式来跟踪已经发生但尚未处理的事件。为实现这个目标，浏览器使用了事件队列，如图2.8所示。

所有已生成的事件（无论是用户生成的，例如鼠标移动或键盘按压，还是服务器生成的，例如Ajax事件）都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。如图2.8的中部所示，事件处理的过程可以描述为一个简单的流程图。

* 浏览器检查事件队列头；
* 如果浏览器没有在队列中检测到事件，则继续检查；
* 如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理。

由于一次只能处理一个事件，所以我们必须格外注意处理所有事件的总时间。执行需要花费大量时间执行的事件处理函数会导致Web应用无响应！（如果听起来还不太明确，不要担心，第13章中我们还会学习事件循环，再看看它是如何损害Web应用在感受上的性能的）。

![](读书笔记：JavaScript忍者秘籍(第2版)/19.png)

重点注意浏览器在这个过程中的机制，其放置事件的队列是在页面构建阶段和事件处理阶段以外的。这个过程对于决定事件何时发生并将其推入事件队列很重要，这个过程不会参与事件处理线程。

#### 事件是异步的

事件可能会以难以预计的时间和顺序发生（强制用户以某个顺序按键或单击是非常奇怪的），我们对事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生。

* 浏览器事件，例如当页面加载完成后或无法加载时；
* 网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）；
* 用户事件，例如鼠标单击、鼠标移动和键盘事件；
* 计时器事件，当timeout时间到期或又触发了一次时间间隔。

Web应用的JavaScript代码中，大部分内容都是对上述事件的处理！

事件处理的概念是Web应用的核心，你在本书中的例子会反复看到：代码的提前建立是为了在之后的某个时间点执行。除了全局代码，页面中的大部分代码都将作为某个事件的结果执行。

在事件能被处理之前，代码必须要告知浏览器我们要处理特定事件。接下来看看如何注册事件处理器。

### 注册事件处理器

前面已经讲过了，事件处理器是当某个特定事件发生后我们希望执行的函数。为了达到这个目标，我们必须告知浏览器我们要处理哪个事件。这个过程叫作注册事件处理器。在客户端Web应用中，有两种方式注册事件。

* 通过把函数赋给某个特殊属性；
* 通过使用内置addEventListener方法。

例如，编写如下代码，将一个函数赋值给window对象上的某个特定属性onload：

~~~javascript
window.onload = function(){};
~~~

通过这种方式，事件处理器就会注册到load事件上（当DOM已经就绪并全部构建完成，就会触发这个事件）。（如果你对赋值操作符右边的记法有些困惑，不要担心，随后的章节中我们会细致地讲述函数）类似，如果我们想要为在文档中body元素的单击事件注册处理器，我们可以输入下述代码：

~~~javascript
document.body.onclick = function(){};
~~~

把函数赋值给特殊属性是一种简单而直接的注册事件处理器方式。但是，我们并不推荐你使用这种方式来注册事件处理器，这是因为这种做法会带来缺点：对于某个事件只能注册一个事件处理器。也就是说，一不小心就会将上一个事件处理器改写掉。幸运的是，还有一种替代方案：addEventL istener方法让我们能够注册尽可能多的事件，只要我们需要。如下清单使用了清单2.3中的示例，向你展示这种便捷的用法。

![](读书笔记：JavaScript忍者秘籍(第2版)/20.png)

本例中使用了某个HTML元素上的内置的方法addEventListener，并在函数中指定了事件的类型（mousemove事件或click）和事件的处理器。这意味着当鼠标从页面上移动后，浏览器会调用该函数添加一条消息到ID位second的list元素上，`"Event：mousemove"`（类似，当body被单击时，`"Event：click"`也会被添加到同样的元素上）。现在你学习了如何创建事件处理器，让我们回忆下前面看到的简单流程图，然后仔细看看事件是如何被处理的。

### 处理事件

事件处理背后的的主要思想是：当事件发生时，浏览器调用相应的事件处理器。如前面提到的，由于单线程执行模型，所以同一时刻只能处理一个事件。任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理！

让我们回到清单2.1中的应用。图2.9展示了在用户快速移动和单击鼠标时的执行情况。

让我们看看这里发生了什么。为了响应用户的动作，浏览器把鼠标移动和单击事件以它们发生的次序放入事件队列：第一个是鼠标移动事件，第二个是单击事件序号1在事件处理阶段中，事件循环会检查队列，其发现队列的前面有一个鼠标移动事件，然后执行了相应的事件处理器序号2。当鼠标移动事件处理器处理完毕后，轮到了等待在队列中的单击事件。当鼠标移动事件处理器函数的最后一行代码执行完毕后，JavaScript引擎退出事件处理器函数，鼠标移动事件完整地处理了序号3，事件循环再次检查队列。这一次，在队列的最前面，事件循环发现了鼠标单击事件并处理了该事件。一旦单击处理器执行完成，队列中不再有新的事件，事件循环就会继续循环，等待处理新到来的事件。这个循环会一直执行到用户关闭了Web应用。

![](读书笔记：JavaScript忍者秘籍(第2版)/21.png)

现在我们有了个总体的认识，理解了事件处理阶段的所有步骤。让我们看看这个过程是如何影响DOM的（如图2.10所示），执行鼠标移动处理器时会选择第二个列表元素，其ID为second。

![](读书笔记：JavaScript忍者秘籍(第2版)/22.png)

然后通过使用addMessage，使用文字"Event：mousemove"添加了一个新的列表项元素序号1。一旦鼠标移动处理器结束后，事件循环执行单击事件处理器，从而创建了另一个列表元素序号2，并附加在ID为second的第二个列表元素后。

对Web应用客户端的生命周期有了清晰的理解后，本书的下一部分，我们会开始聚焦于JavaScript语言，理清函数的来龙去脉。

## 小结

* 浏览器接收的HTML代码用作创建DOM的蓝图，它是客户端Web应用结构的内部展示阶段。
* 我们使用JavaScript代码来动态地修改DOM以便给Web应用带来动态行为。
* 客户端Web应用的执行分为两个阶段。
  * 页面构建代码是用于创建DOM的，而全局JavaScript代码是遇到script节点时执行的。在这个执行过程中，JavaScript代码能够以任意程度改变当前的DOM，还能够注册事件处理器-事件处理器是一种函数，当某个特定事件（例如，一次鼠标单击或键盘按压）发生后会被执行。注册事件处理器很容易：使用内置的addEventListener方法。
  * 事件处理——在同一时刻，只能处理多个不同事件中的一个，处理顺序是事件生成的顺序。事件处理阶段大量依赖事件队列，所有的事件都以其出现的顺序存储在事件队列中。事件循环会检查实践队列的队头，如果检测到了一个事件，那么相应的事件处理器就会被调用。

## 练习

* 客户端Web应用的两个生命周期阶段是什么？
* 相比将事件处理器赋值给某个特定元素的属性上，使用addEventListener方法来注册事件处理器的优势是什么？
* JavaScript引擎在同一时刻能处理多少个事件？
* 事件队列中的事件是以什么顺序处理的？

# 第二部分：理解函数

现在你已做好心理准备，并理解了JavaScript代码的执行环境，准备开始学习JavaScript的基础特性。

在第3章中，你将学习JavaScript中最重要的基础概念：不是对象，而是函数。本章将阐述为何函数是开启JavaScript语言之谜的钥匙。

第4章深入研究函数，研究如何调用函数，以及函数执行过程中隐式传递参数的来龙去脉。

第5章通过闭包，让你对函数的理解更上一层楼也许闭包是JavaScript语言中最容易被误解的部分。很快你就会看到，闭包与作用域密不可分。在本章中，除了闭包，我们重点关注Javascript中的作用域机制。

第6章结束对函数的研究。在本章中我们讨论一种全新的函数类型-generator函数。该函数具有在处理异步代码过程中特别重要的一些特性。

# 第3章：新手的第一堂函数课：定义与参数

![](读书笔记：JavaScript忍者秘籍(第2版)/23.png)

在本书这一部分讨论JavaScript基础时，也许你会感到惊讶，我们的第一个论点是函数（function）而非对象（object），当然，第3部分会用大量笔墨解释对象，但归根结底，你要理解一些基本事实，像普通人一样编写代码和像“忍者”一样编写代码的最大差别在于**是否把JavaScript作为函数式语言（functional language）来理解**。对这一点的认知水平决定了你编写的代码水平。

如果你正在阅读这本书，那么你应该不是一位初学者。对于后续内容，我们假设你已经足够了解面向对象基础（当然，我们会在第7章详细讨论对象的高级概念），但真正理解JavaScript中的函数才是你能使用的唯一一件重要武器。函数是如此重要，所以本章及接下来两章将带领你彻底理解JavaScript中的函数。

JavaScript中最关键的概念是：**函数是第一类对象（first-class objects）**，或者说它们被称作一等公民（first-class citizens）。函数与对象共存，**函数也可以被视为其他任意类型的JavaScript对象**。函数和那些更普通的JavaScript数据类型一样，它能**被变量引用**，能以字面量形式声明，甚至能**被作为函数参数进行传递**。本章一开始会介绍面向函数编程带来的差异，你会发现，**在需要调用某函数的位置定义该函数，能让我们编写更紧凑**、更易懂的代码。**其次**，我们还会探索如何把函数用作第一类对象来编写高性能函数。你能学到多种不同的函数定义方式，甚至包括一些新类型，例如箭头（arrow）函数，它能帮你编写更优雅的代码。**最后**，我们会学习函数**形参和函数实参的区别**，并重点关注ES6的新增特性，例如**剩余参数和默认参数**。

让我们通过了解函数式编程的优点来开始学习吧。

![](读书笔记：JavaScript忍者秘籍(第2版)/24.png)

## 函数式的不同点到底是什么

函数及函数式概念之所以如此重要，其原因之一在于**函数是程序执行过程中的主要模块单元**。**除了全局JavaScript代码**是在页面构建的阶段执行的，**我们编写的所有的脚本代码都将在一个函数内执行**。

由于我们的大多数代码会作为函数调用来执行，因此，我们在编写代码时，通用强大的**构造器**能赋予代码很大的灵活性和控制力。本书的大部分内容解释了如何利用函数作为第一类对象的特性获益。**首先**浏览一下对象中我们能使用的功能。JavaScript中**对象**有以下几种常用功能。

* 对象可通过字面量来创建{}。
* 对象可以赋值给变量、数组项，或其他对象的**属性**。

![](读书笔记：JavaScript忍者秘籍(第2版)/25.png)

![](读书笔记：JavaScript忍者秘籍(第2版)/26.png)

其实，不同于很多其他编程语言，在 JavaScript 中，**我们几乎能够用函数来实现同样的事**。

### 函数是第一类对象

**JavaScript中函数拥有对象的所有能力(那这样的话对象有什么函数所不具有的优势呢？否则直接全部都用函数不就好了)**，也因此函数可被作为任意其他类型对象来对待。当我们说函数是第一类对象的时候，就是说函数**也能够实现以下功能**。

![](读书笔记：JavaScript忍者秘籍(第2版)/27.png)

对象能做的任何一件事，函数也都能做。**函数也是对象**，**唯一的特殊之处在于它是可调用的（invokable）**，即**函数会被调用以便执行某项动作**。

> **把函数作为第一类对象是函数式编程（functional programming）的第一步**，函数式编程是一种编程风格，它通过书写函数式（而不是指定一系列执行步骤，就像那种更主流的命令式编程）代码来解决问题。函数式编程可以让代码更容易测试、扩展及模块化。不过这是一个很大的话题，因此本书仅对这个特性做了肯定（例如，在第9章中）。如果你对如何在JavacScript中利用函数式编程感兴趣，推荐阅读Luis Atencio著（由Manning出版社2016年出版）的《JavaScript函数式编程》。

第一类对象的特点之一是，**它能够作为参数传入函数**。对于函数而言，这项特性也表明：**如果我们将某个函数作为参数传入另一个函数，传入函数会在应用程序执行的未来某个时间点才执行**。大家所知道的更一般的概念是回调函数（callback function）。下面我们来学习这个重要概念。

### 回调函数

每当我们建立了一个**将在随后调用的函数时**，无论是在事件处理阶段通过浏览器还是通过其他代码，我们都是在**建立一个回调（callback）**，这个术语源自于这样一个事实，即**在执行过程中，我们建立的函数会被其他函数在稍后的某个合适时间点“再回来调用”**。

有效运用JavaScript的关键在于回调函数，相信你已经在代码中使用了很多回调函数——不论是单击一次按钮、从服务端接收数据，还是UI动画的一部分。

本节我们会看一些实际使用回调函数的典型例子，例如处理事件、简单的排序集合。这部分内容会有点复杂，所以在深入学习之前，**先透彻、完整地理解回调函数的概念，用最简单的形式来展现它**。下面我们用一个简单例子来阐明这个概念，此例中的函数完全没什么实际用处，**它的参数接收另一个函数的引用，并作为回调调用该函数**：

~~~javascript
function useless(ninjaCallback) {
	return ninjaCallback();
}
~~~

这个函数可能没什么用，但**它反映了函数的一种能力**，即将函数作为另一个函数的参数，随后通过参数来调用该函数。

我们可以在清单3.1中测试一下这个名为useless的函数。

![d](读书笔记：JavaScript忍者秘籍(第2版)/28.png)

在这个代码清单中，我们使用**自定义函数report**（在本书附录B中定义）来输出代码执行过程中的信息，这样一来我们就能通过这些信息来跟踪程序的执行过程。我们还使用了**第1章中的断言函数assert**，该函数通常使用两个参数。第一个参数是用于断言的表达式。本例中，我们需要确定使用参数getText调用useless函数返回的值与变量text是否相等`(useless(getText)===text)`，若第一个参数的执行结果为true，断言通过；反之，断言失败。**第二个参数是与断言相关联的信息，通常会根据通过/失败来输出到日志上**。（附录B中概括地探讨了测试，以及我们对assert函数和report函数的简单实现）。

这段代码执行完毕后，执行结果如图3.1所示。可以看到，使用getText参数调用useless回调函数后，得到了期望的返回值。

![](读书笔记：JavaScript忍者秘籍(第2版)/29.png)

我们还可以看看这个简单的回调函数具体是如何执行的。如图3.2所示，getText函数作为参数传入了useless函数。从该图中可以看到，在useless函数体内，通过callback参数可以取得getText函数的引用。随后，回调函数`callback()`的调用让getText函数得到执行，而我们作为参数传入的getText函数则通过useless函数被回调。

![](读书笔记：JavaScript忍者秘籍(第2版)/30.png)

完成这个过程是很容易的，原因就在于JavaScript的函数式本质让我们能把函数作为第一类对象。更进一步说，我们的代码可以写成如下形式：

![](读书笔记：JavaScript忍者秘籍(第2版)/31.png)

JavaScript的重要特征之一是**可以在表达式出现的任意位置创建函数**，除此之外这种方式能使代码更紧凑和易于理解（**把函数定义放在函数使用处附近**）。当一个函数不会在代码的多处位置被调用时，该特性可以避免用非必须的名字污染全局命名空间。在回调函数的前述例子中，我们调用的是我们自己的回调。除此之外**浏览器也会调用回调函数**，回想一下第2章中的下述例子：

~~~javascript
document.body.addEventListener("mousemove", function() {
	var second = document.getElementById("second");
	addMessage(second, "Event: mousemove");
});
~~~

上例同样是一个回调函数，作为mousemove事件的事件处理器，当事件发生时，会被浏览器调用。

![](读书笔记：JavaScript忍者秘籍(第2版)/33.png)

现在让我们看一个回调函数的用法，它能极大地**简化集合的排序**。

#### 使用比较器排序

[原生JS数组sort()排序方法内部原理探究--写的很好](https://juejin.cn/post/6844903941046550542)

一般情况下只要我们拿到了一组数据集，就很可能需要对它进行排序。假如有一组随机序列的数字数组：0，3，2，5，7，4，8，1，也许这个顺序没什么问题，但**很可能早晚需要重新排列它**。

通常来说，实现排序算法并不是编程任务中最微不足道的；我们需要为手中的工作选择**最佳算法**，实现它以适应当前的需要（使这些选项是按照特定顺序排列），并且需要小心仔细不能引入故障。除此之外，唯一特定于应用程序的任务是排列顺序。幸运的是，**所有的JavaScript数组都能用sort方法**。利用该方法可以只定义一个比较算法，比较算法用于指示按什么顺序排列。

这才是回调函数所要介入的！不同于让排序算法来决定哪个值在前哪个值在后，我们将会提供一个函数来执行比较。**我们会让排序算法能够获取这个比较函数作为回调，使算法在其需要比较的时候，每次都能够调用回调**。该回调函数的期望返回值为：**如果传入值的顺序需要被调换，返回正数；不需要调换，返回负数；两个值相等，返回0**。对于排序上述数组，我们对比较值做减法就能得到我们所需要的值。

~~~javascript
var values = [0, 3, 2, 5, 7, 4, 8, 1];
values.sort(function(value1, value2) {
	return value1 - value2;
});

console.log([80, 9, 100].sort((a, b) => a - b));
// [ 9, 80, 100 ]
~~~

> 这个我一直都没有搞懂啊！！看了一篇文章，大概了解一些了，里面用了一些排序算法。

没有必要思考排序算法的底层细节(甚至是选择了什么算法)，JavaScript引擎每次需要比较两个值的时候都会调用我们提供的回调函数。

**函数式方式让我们能把函数作为一个单独实体来创建**，正像我们对待其他类型一样，创建它、作为参数传入一个方法并将它作为一个参数来接收。函数就这样显示了它一等公民的地位。

## 函数作为对象的乐趣

本节我们会考察函数和其他对象类型的相似之处。也许让你感到惊讶的相似之处在于**我们可以给函数添加属性**：

![](读书笔记：JavaScript忍者秘籍(第2版)/32.png)

我们再来看看这种特性所能做的更有趣的事：

* 在集合中存储函数使我们轻易管理相关联的函数。例如，某些特定情况下必须调用的回调函数。
* **记忆让函数能记住上次计算得到的值，从而提高后续调用的性能。**

让我们行动起来吧。

### 存储函数

某些例子中（例如，我们需要**管理某个事件发生后需要调用的回调函数集合**），我们**会存储元素唯一的函数集合(这个就是map吧)**。当我们向这样的集合中添加函数时，会面临两个问题：哪个函数对于这个集合来说是一个新函数，从而需要被加入到该集合中？又是哪个函数已经存在于集合中，从而不需要再次加入到集合中？一般来说，**管理回调函数集合时，我们并不希望存在重复函数**，否则一个事件会导致同一个回调函数被多次调用。

一种显著有效的简单方法是**把所有函数存入一个数组，通过循环该数组来检查重复函数**。令人遗憾的是，这种方法的**性能较差**，尤其作为一个“忍者”要把事情干得漂亮而不仅是做到能用。我们可以使用函数的属性，用适当的复杂度来实现它，如清单3.2所示。

![](读书笔记：JavaScript忍者秘籍(第2版)/34.png)

> 像这样的代码自己功力还不够啊，还无法透彻理解啊！！

在这个清单中，我们**创建了一个对象**赋值给**变量**store，这个**变量中存储的是唯一的函数集合**。这个对象有两个数据属性：其一是下一个可用的id，另外一个缓存着已经保存的函数。函数通过`add()`方法添加到缓存中。

![](读书笔记：JavaScript忍者秘籍(第2版)/35.png)

> 现在是2020年11月06日，我发现我开始看不下去了，我现在的水平有点看不懂了。也许是看的太快的缘故吧，上班的时候看的，没有边看边敲代码，印象不深。
>
> 现在是2021年1月26日，我开始从第三章从头开始看，看的比较慢，慢慢看得懂了,起码比以前进步了。

在 add 函数内，我们首先检查该函数是否已经存在 id 属性。如果当前的函数已经有 id属性，我们则假设该函数已经被处理过了，从而忽略该函数，否则为该函数分配一个id(同时增加 nextId)属性，**并将该函数作为一个属性增加到 cache 上**，id 作为属性名。紧接着该函数的返回值为true，从而可得知调用了`add()`后，函数是什么时候被添加到存储中的。

在浏览器中运行该程序后，页面显示：测试程序尝试两次添加`ninja()`函数，**而该函数只被添加一次到存储中**，如图 3.3 所示。第 9 章展示了用于操作合集的更好技术，它利用了 ES6 的新的对象类型集合（Set）。

![](读书笔记：JavaScript忍者秘籍(第2版)/36.png)

另外一种有用的技巧是当使用函数属性时，可以通过该属性修改函数自身。这个技术可以用于记忆前一个计算得到的值，为之后计算节省时间。

### 自记忆函数

如同前面所提到的，记忆化（memoization）是一种构建函数的处理过程，能够记住上次计算结果。在这个果壳里，**当函数计算得到结果时就将该结果按照参数存储起来**。采用这种方式时，如果**另外一个调用**也**使用相同的参数**，我们则**可以直接返回上次存储的结果而不是再计算一遍**。像这样**避免既重复又复杂的计算可以显著地提高性能**。对于动画中的计算、搜索不经常变化的数据或任何耗时的数学计算来说，记忆化这种方式是十分有用的。

看看下面的这个例子，它使用了一个简单的（也的确是效率不高的）算法来计算素数。尽管这是一个复杂计算的简单例子，但它经常被应用到大计算量的场景中（例如可以引申到通过字符串生成 MD5 算法），这里不便展示。

从外表来说，这个函数和任何普通函数一样，但在内部我们会**构建一个结果缓存**，它会**保存函数每次计算得到的结果**，如清单 3.3 所示。

![](读书笔记：JavaScript忍者秘籍(第2版)/37.png)

> 我什么时候可以很轻松的看懂上面的代码就好了，现在看的很费劲。

在isPrime函数中，首先通过检查它的answers属性来确认是否已经创建了一个缓存，如果没有创建，则新建一个：

~~~javascript
if (!isPrime.answers) {
	isPrime.answers = {};
}
~~~

**只有第一次函数调用才会创建这个初始空对象，之后这个缓存就已经存在了**。然后我们会检查参数中传的值是否已经存储到缓存中：

~~~javascript
if (isPrime.answers[value] !== undefined) {
	return isPrime.answers[value];
}
~~~

这个缓存会针对参数中的值 value 来存储该值是否为素数（true 或 false）。如果我们在缓存中找到该值，函数会直接返回。

~~~javascript
return isPrime.answers[value] = prime;
~~~

这个缓存是函数自身的一个属性，所以只要该函数还存在，缓存也就存在。最后的测试结果可以看到记忆函数生效了。

~~~javascript
assert(isPrime(5), "5 is prime!");
assert(isPrime.answers[5], "The answer was cached!");
~~~

这个方法具有两个优点。

* 由于函数调用时会寻找之前调用所得到的值，所以用户最终会乐于看到所获得的性能收益。
* 它几乎是无缝地发生在后台，最终用户和页面作者都不需要执行任何特殊请求，也不需要做任何额外初始化，就能顺利进行工作。

当然这种方法并不是像玫瑰和提琴一样完美，还是要权衡利弊。

* 任何类型的缓存都必然会为性能牺牲内存。
* 纯粹主义者会认为缓存逻辑不应该和业务逻辑混合，函数或方法只需要把一件事做好。但不必担心，在第 8 章你会了解到如何解决这类问题。*
* 对于这类问题很难做负载测试或估计算法复杂度，因为结果依赖于函数之前的输入。

现在你看到了函数作为第一类公民的一些实例，接下来看看不同的函数定义的方式。

## 函数定义

JavaScript 函数通常由函数字面量（function literal）来创建函数值，就像数字字面量创建一个数字值一样。要记住这一点，作为第一类对象，函数是可以用在编程语言中的值，就像例句字符串或数字的值。无论你是否意识到了这一点，你一直都是这样做的。

JavaScript 提供了几种定义函数的方式，可以分为 4 类。

* **函数定义**（function declarations）和函数表达式（function expressions）——最常用，在定义函数上却有微妙不同的的两种方式。人们通常不会独立地看待它们，但正如你将看到的，意识到两者的不同能帮我们理解函数何时能够被调用。

  ~~~javascript
  function myFun(){ return 1;}
  ~~~

* **箭头函数**（通常被叫做 lambda 函数）——ES6 新增的 JavaScript 标准，能让我们以尽量简洁的语法定义函数。

  ~~~javascript
  myArg => myArg*2
  ~~~

* **函数构造函数**—— 一种不常使用的函数定义方式，能让我们以字符串形式动态构造一个函数，这样得到的函数是动态生成的。这个例子动态地创建了一个函数，其参数为 a 和 b，返回值为两个数的和。

  ~~~javascript
  new Function('a', 'b', 'return a + b')
  ~~~

* **生成器函数**——ES6 新增功能，能让我们创建不同于普通函数的函数，在应用程序执行过程中，这种函数能够退出再重新进入，在这些再进入之间保留函数内变量的值。我们可以定义生成器版本的函数声明、函数表达式、函数构造函数。

  ~~~javascript
  function* myGen(){ yield 1; }
  ~~~

  > 生成器函数是真的不熟，做的项目也没有使用过这个函数。

理解这几种方式的不同很重要，因为函数创建的方式很大程度地影响了函数可被调用的时间、函数的行为以及函数可以在哪个对象上被调用。

这一节中，我们将会探索函数定义、函数表达式和箭头函数。你将学到它们的语法和它们的工作方式，我们也将会在本书中多次回顾它们的细节。另一方面，生成器函数则有一点独特，它不同于普通函数。在第 6 章我们会再来学习它们的细节。

剩下的 JavaScript 特性——函数构造函数我们将全部跳过。尽管它具有某些有趣的应用场景，尤其是在动态创建和执行代码时，但我们依然认为它是 JavaScript 语言的边缘功能。如果你想知道更多关于函数构造函数的信息，请访问 http://mng.bz/ZN8e。

让我们先用最简单、最传统的方式定义函数吧：函数声明和函数表达式。

> 现在是2021年1月26日，第三章截止到这里复习完。

### 函数声明和函数表达式

JavaScript 中定义函数最常用的方式是函数声明和函数表达式。这两种技术非常相似，有时甚至难以区分，但在后续章节中你将看到，它们之间还是存在着微妙的差别。

#### 函数声明

![](读书笔记：JavaScript忍者秘籍(第2版)/38.png)

声明以强制性的 function 开头，其后紧接着强制性的函数名，以及括号和括号内一列以逗号分隔的可选参数名。函数体是一列可以为空的表达式，这些表达式必须包含在花括号内。除了这种形式以外，每个函数声明还必须包含一个条件：作为一个单独的JavaScript语句，函数声明必须独立（但也能够被包含在其他函数或代码块中，在下一小节中你将会准确理解其含义）。

清单 3.4 展示了两条函数声明例子。

![](读书笔记：JavaScript忍者秘籍(第2版)/39.png)

如果你对函数式语言没有太多了解，仔细看一看，你可能会发现你并不习惯这种使用方式: 一个函数被定义在另一个函数之中！

~~~javascript
function ninja() {
	function hiddenNinja() {
		return "ninja here";
	}
	return hiddenNinja();
}
~~~

在 JavaScript 中，这是一种非常通用的使用方式，这里用它作为例子是为了再次强调 JavaScript 中函数的重要性。

> 注意：让函数包含在另一个函数中可能会因为忽略作用域的标识符解析而引发一些有趣的问题，但现在可以先留下这个问题，第 5 章会重新回顾这个问题的细节。

#### 函数表达式

正如我们多次所提到的，JavaScript 中的函数是第一类对象，除此以外也就意味着它们可以通过字面量创建，可以赋值给变量和属性，可以作为传递给其他函数的参数或函数的返回值。正因为函数有如此的基础结构，所以 JavaScript 能让我们把函数和其他表达式同等看待。例如，如下例子中我们可以使用数字字面量：

~~~javascript
var a = 3;
myFunction(4);
~~~

同样，在相同位置可以用函数字面量：

~~~javascript
var a = function() {};
myFunction(function(){});
~~~

这种总是其他表达式的一部分的函数（作为赋值表达式的右值，或者作为其他函数的参数）叫作函数表达式。函数表达式非常重要，在于它能准确地在我们需要使用的地方定义函数，这个过程能让代码易于理解。清单 3.5 展示了函数声明和函数表达式的不同之处。

![](读书笔记：JavaScript忍者秘籍(第2版)/41.png)

从这个示例中你能够看到，函数声明是如何作为 JavaScript 代码中的独立表达式的，但它也能够包含在其他函数体内。与之比较的是函数表达式，它通常作为其他语句的一部分。它们被放在表达式级别，作为变量声明（或者赋值）的右值：

~~~javascript
var myFunc = function(){};
~~~

或者作为另一个函数调用的参数或返回值。

~~~javascript
myFunc(function() {
	return function(){};
});
~~~

函数声明和函数表达式除了在代码中的位置不同以外，还有一个更重要的不同点是：对于函数声明来说，函数名是强制性的，而对于函数表达式来说，函数名则完全是可选的。

函数声明必须具有函数名是因为它们是独立语句。一个函数的基本要求是它应该能够被调用，所以它必须具有一种被引用方式，于是唯一的方式就是通过它的名字。

从另一方面来看，函数表达式也是其他 JavaScript 表达式的一部分，所以我们也就具有了调用它们的替代方案。例如，如果一个函数表达式被赋值给了一个变量，我们可以用该变量来调用函数。

~~~javascript
var doNothing = function(){};
doNothing();
~~~

或者，如果它是另外一个函数的参数，我们可以在该函数中通过相应的参数名来调用它。

~~~javascript
function doSomething(action) {
	action();
}
~~~

#### 立即函数

函数表达式可以放在初看起来有些奇怪的位置上，例如通常认为是函数标识符的位置。接下来仔细看看这个构造（如图 3.5 所示）。

![](读书笔记：JavaScript忍者秘籍(第2版)/42.png)

当想进行函数调用时，我们需要使用能够求值得到函数的表达式，其后跟着一对函数调用括号，括号内包含参数。在最基本的函数调用中，我们把求值得到函数的标识符作为左值（如图 3.5 所示）。不过用于被括号调用的表达式不必只是一个简单的标识符，它可以是任何能够求值得到函数的表达式。例如，指定一个求值得到函数的表达式的最简单方式是使用函数表达式。如图 3.5 中右图所示，我们首先创建了一个函数，然后立即调用这个新创建的函数。这种函数叫作立即调用函数表达式（IIFE），或者简写为立即函数。这一特性能够模拟 JavaScript 中的模块化，故可以说它是 JavaScript 开发中的重要理念。第 11 章中会集中讨论 IIFE 的应用。

![](读书笔记：JavaScript忍者秘籍(第2版)/43.png)

表3.5中最后4个表达式都是立即调用函数表达式主题的4个不同版本，在JavaScript库中会经常见到这几种形式：

~~~javascript
+function(){}();
-function(){}();
!function(){}();
~function(){}();
~~~

不同于用加括号的方式区分函数表达式和函数声明，这里我们使用一元操作符`+`、`-`、`!`和`~`。这种做法也是用于向 JavaScript 引擎指明它处理的是表达式，而不是语句。从计算机的角度来讲，注意应用一元操作符得到的结果没有存储到任何地方并不重要，只有调用 IIFE 才重要。现在我们已经学会了 JavaScript 中两种基本的函数定义方式（函数声明和函数表达式）的细节。接下来开始探索 JavaScript 标准中的新增特性：箭头函数。

### 箭头函数

> 注意 箭头函数是JavaScript 标准中的ES6新增项（浏览器兼容性可参考http://mng.bz/8bnH）。

由于 JavaScript 中会使用大量函数，增加简化创建函数方式的语法十分有意义，也能让我们的开发者生活更愉快。在很多方式中，箭头函数是函数表达式的简化版。一起来回顾一下本章开始的排序例子。

~~~javascript
var values = [0, 3, 2, 5, 7, 4, 8, 1];
values.sort(function(value1,value2){
	return value1 – value2;
});
~~~

这个例子中，数组对象的排序方法的参数传入了一个回调函数表达式，JavaScript引擎会调用这个回调函数以降序排序数组。现在来看看如何用箭头函数来做完全相同的工作：

~~~javascript
var values = [0, 3, 2, 5, 7, 4, 8, 1];
values.sort((value1,value2) => value1 – value2);
~~~

到这是多么简洁了吧？

这种写法不会产生任何因为书写 function 关键字、大括号或者 return 语句导致的混乱。箭头函数语句有着比函数表达式更为简单的方式：函数传入两个参数并返回其差值。注意这个新操作符——胖箭头符号`=>`（等号后面跟着大于号）是定义箭头函数的核心。

现在来解析箭头函数的语法，首先看看它的最简形式：

~~~javascript
param => expression
~~~

这个箭头函数接收一个参数并返回表达式的值，如下面的清单 3.6 就使用了这种语法。

![](读书笔记：JavaScript忍者秘籍(第2版)/44.png)

稍作欣赏，使用箭头函数的代码即简洁又清楚。这是箭头函数的最简语法，但一般情况下，箭头函数会被定义成两种方式，如图 3.6 所示。

如你所见，箭头函数的定义以一串可选参数名列表开头，参数名以逗号分隔。如果没有参数或者多余一个参数时，参数列表就必须包裹在括号内。但如果只有一个参数时，括号就不是必须的。参数列表之后必须跟着一个胖箭头符号，以此向我们和 JavaScript引擎指示当前处理的是箭头函数。

胖箭头操作符后面有两种可选方式。如果要创建一个简单函数，那么可以把表达式放在这里（可以是数学运算、其他的函数调用等），则该函数的返回值即为此表达式的返回值。例如，第一个箭头函数的示例如下：

~~~javascript
var greet = name => "Greetings " + name;
~~~

![](读书笔记：JavaScript忍者秘籍(第2版)/45.png)

这个箭头函数的返回值是字符串“Greetings”和参数 name 的结合。在其他案例中，当箭头函数没那么简单从而需要更多代码时，箭头操作符后则可以跟一个代码块，例如：

~~~javascript
var greet = name => {
	var helloString = 'Greetings ';
	return helloString + name;
};
~~~

这段代码中箭头函数的返回值和普通函数一样。**如果没有 return 语句，返回值是undefined**；反之，返回值就是 return 表达式的值。

在本书中我们会多次回顾箭头函数。除此之外，我们还会展示箭头函数的一些额外功能，它能帮助我们规避一些在很多标准函数中可能遇到的难以捉摸的缺陷。箭头函数和很多其他函数一样，可以通过接收参数来执行任务。接下来看看当向函数内传入参数后，该参数值发生了什么。

## 函数的实参和形参

