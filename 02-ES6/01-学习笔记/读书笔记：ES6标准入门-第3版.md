---
title: 读书笔记：ES6标准入门(第3版)
date: 2020-02-23 21:42:57
tags: 读书笔记
categories: 前端理论
---

(注1：现在是2020年9月18日，我觉得这是一本挺不错的书，不过我应该不会从头到尾看了，我是想看哪里就先看哪里，以一种不是那么顺序的方式把它看完。)

(注2：如果我按照顺序看的话，我估计受不了，因为这本书也不容易懂。)

(注3：不然以后就这样了：难的书就不按顺序看了，这样轻松一些。)

(注4：现在是2020年9月24日，之前我写的博文这本书里面的大量代码还要自己手敲，今天才注意到自己很久收藏的一个网站就是这本书的电子版[ECMAScript 6 简介](https://wangdoc.com/es6/intro.html),这下好了，可以直接在网页上复制内容和代码了，不过自己还要看的更加仔细才行。我们的目的不是把这本书以一定的速读看完，而是要把它给看懂。)

(注5：但是这个网上的电子版和书上的内容还有些出入，明显书上的内容更加的详实一些，所以自己还要进行勘误，先以书上的内容为主吧。)

(注6：现在是2020年10月22日，这本书真的是要花时间好好看一下，ES6语法真的是挺重要的，这个也值得好好学一下。以后就慢慢的往这本书里面添加内容，把它给弄详实一些啊。)

(注7：这本书的电子版另一个地址[ECMAScript6入门](https://es6.ruanyifeng.com/#README))

(注8：现在是2021年3月11日，我开始有了深的感触：ES6一定要学好啊！！！)

(注9：[ES6大纲如下](https://zhuanlan.zhihu.com/p/87699079))

![](读书笔记：ES6标准入门-第3版/14.png)

![](读书笔记：ES6标准入门-第3版/15.png)

![](读书笔记：ES6标准入门-第3版/16.png)

![](读书笔记：ES6标准入门-第3版/17.png)

![](读书笔记：ES6标准入门-第3版/18.png)

![](读书笔记：ES6标准入门-第3版/19.png)

![](读书笔记：ES6标准入门-第3版/20.png)

![](读书笔记：ES6标准入门-第3版/21.png)

# 推荐序1

## 为什么我们要关心标准

"ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。”

本书第1章的这句话已经清楚地告诉我们，这是一本**不实用**的书。我们学习了这本书，并不意味着掌握了一项实用的技术，而只是掌握了一个未来可能会发布的技术标准。而标准，有可能在将来被实现，变成主流，也有可能就仅仅是一个标准，没有人真的去实践它。如果你再了解一下第1章里面介绍的ECMAScript 4.0草案的血泪史，或者回顾一下曾经红极一时的XHTML，就更容易明白这一点了。

那我们为什么不直接忽略标准，拥抱实践就好呢？来，我们一起翻开小学课本，跟我念：柏林已经来了命令，阿尔萨斯和洛林的学校只许教德语了（最后一课》）

当“统治者”宣布一门语言成为“标准”的时候，不管是在现实生活还是技术领域里面，往往就意味着所有其他的选项自动消失了，我们只能去学习“统治者”的语言。幸运的是，在技术领域里面，跳出来争取对技术的影响力和主导权，不但不违反任何一国的宪法，往往还是被鼓励的。

因此，技术的未来发展，是我们可以去发出声音，去影响，乃至于去引领的。而要做到这些，我们需要搞清楚，ECMA和各大互联网巨头们，他们正在做什么，正在把技术往哪里引领；他们引领的方向，到底是对所有人有利的，还是只是对某些公司有利；我们中国的开发者和中国的公司，要怎么加入到这些标准的制订过程中，把标准带到更好的方向上。

最近几年，越来越多的中国公司加入到各种国际标准组织中，参与到各种标准（尤其是在东亚文字处理、排版、输入法相关的领域）制订过程中，发出了中国技术人员的声音。随着中国国力的增强，中国开发厂商和技术人员的影响力的发展壮大，可以预见，不久的将来，中国工程师也许会深入参与到ECMAScript7和HTML6这样的技术标准的制订过程里面，跟各国的专家一起探讨，我们中国的开发者不喜欢这样，更喜欢那样。在那些标准大会上，我们的发言权将来自于我们对标准的深入理解、我们对技术发展的独到眼光和我们建设起来的技术影响力。

作为一个JS开发者，实话说，对于ECMAScript 6里面的很多内容（比如let语句），我并不完全认同。但是很遗憾，这个标准的制定过程没我们什么事。但是如果我们从现在开始关注国际标准，翻译标准文档，让更多人了解标准，更多公司加入标准组织、参与标准制订，也许未来的中国技术圈不但会是很多人的一个圈子，还会是很有影响力的一个圈子。

# 推荐序2

因为一件往事，我现在轻易不敢给别人写序或者书评。那天我在想，如果我要给这本书写序，是不是应该先把这本书拿给贺老（hax）看看。后来呢，我到阮一峰老师的GitHub上看了一看，发现这本书有7500多个star，若干个已解决和未解决的issue，所以我就放心了。开源真是好啊！

这本书是关于ES6的，我对ES6并没有特别系统的研究，但是也在工作中使用了一部分ES6的特性，使用得最多的是Promise，其他的特性只是研究，很少使用，主要是因为本身支持ES6的环境和工具有限。浏览器就不说了，现在的前端工程师在一些产品中能够抛弃1E6已经是很幸福的事情了，但是即使是1E8，离真正的ES6也还很遥远。在其他领域，比如手机游戏领域，cocos2d-js v3.0使用的脚本引擎是SpiderMonkey v28，因此情况要好很多，但是周边的一些工具，比如closure copiler不能很好地压缩和优化ES6，当然你可以采用转换工具先将ES6转成ES5，然后再做压缩和优化，但是这多出来的一步造成更多出错的可能，而且和享受ES6的语法糖的快乐相比，开销有点大-如果无论如何需要再转一步，那么为什么我们不干脆考虑TypeScript或者其他选择呢？

为什么会选择使用ES6的Promise呢？那是因为Promise算是比较好解决异步嵌套问题的方案，另外Promise本身在低版本下也有比较好的polyfill实现（https://github.com/jakearchibald/es6-promise），对于我和一些前端工程师来说，是十分乐意为将来去写一些能够向前兼容的符合标准的代码的。

目前这个阶段，前端学习ES6并不意味着能够很快将ES6的好处带到工作中，因为我们毕竟还受到现在的浏览器环境的制约。但是，即使单纯从学习一门编程语言的核心API的角度来说，ES6也是值得学习的。它的很多新特性，真正涉及现代编程语言概念中很流行的部分，不管是解构赋值还是迭代器或者yield，都是超棒超赞的思想，不但易于理解，也能节省很多键盘操作，而另一些诸如const、作用域之类的设定，则让脚本引擎代替程序员人肉检查做更多的事情，让我们最终上线的代码变得更加安全和更加优美。

不管怎样，ES6代表着一种前端的未来，这种未来，无疑能让前端工程师们工作得更高效，也更有乐趣。更进一步说，ECMAScript还是开放的标准，对这门语言的新特性，有什么好的想法，都是有机会提交为标准的，也就是说，前端程序员的未来，是由我们前端程序员自己来创造的，还有什么是比自由更加美好的呢？所以，为了未来，加油！

# 推荐序3

同大多数读者一样，我最早看到阮一峰先生的文字是在其博客上。他的第一篇博文于2003年写就，迄今已有1500多篇文章，可谓高产。阮先生并非计算机相关专业，但这一点并没有妨碍他从事技术写作，其文字朴实，思路清晰，所有人都能看懂，更能感受到他写文章的用心程度，而这本书完美地体现了他的一贯风格。另外，这本书是开源作品，也很好地践行了他一贯的贡献原则。

自我写下第一行前端代码到现在已经十来年了，前端的基础设施也发生了巨大的变化。变化最大的还是浏览器环境，从原来烂熟IE6的各种bug和hack，到现在IE6已经完全不在我的考虑范围内。其次是前端的工程化程度，2011年，我做FIS（http:/fis.baidu.com）时，完全没想到前端的工程化进展会如此之快。而变化最慢的，要数语言本身了，1999年发布的ECMAScript3.0其实相当于第1版：10年后的2009年发布了第2版：ECMAScript 5.0；ECMAScript 6则是2015年发布的。

我的一贯主张是，要学好JavaScript，ECMAScript标准比什么书都强。ECMAScript标准已经用最严谨的语言和最完美的角度展现了语言的实质和特性。理解语言的本质后，你已经从沙堆里挑出了珍珠，能经受得起时光的磨砺。

我从2009年开始正式接触ECMAScript规范，当时我在写百度的JavaScript基础库Tangram
1.0，ECMAScript 5还处于草案状态。我自己打印了一本小册子，上下班时在地铁上慢慢看。那时才知道，有很多问题在网络上被包装了太多次，解释得千奇百怪，但用规范的语言来描述竟是如此简单。

ECMAScript标准经历了很多变故-尤其是ECMAScript4那次-也从语言的角度反映了各大厂商之间的立场差异。不过，ECMAScript 5的正式发布和发展，为所有Web开发者奠定了稳定的基础，尽管浏览器之间存在大量差异，尤其是DOM，但在JavaScript语言层面，都相对严格地遵循着ECMAScript 5的规范。

JavaScript遵守“一个JavaScript"的原则，所有版本都需要向后兼容。web语言的解释器版本不是由开发者而是由用户决定的，所以JavaScript无法像Python、Ruby，Perl那样，发布一个不向下兼容的大版本，这也就是ECMAScript 4失败的根源，由于它会导致大量已有网页的"bug"，浏览器厂商会强烈反对。当然，ECMAScript6的strict mode也在尝试逐步淘汰一些不良实践。

ECMAScript 6相比5有了很大的进步。经过这次改进，JavaScript语法更精简，变得更有表现力了；在严格模式下，开发者受到了适当而必要的约束；新增了几种数据类型（map、set）
和函数能力（Generator，迭代器）；进一步强化了JavaScript的特点（promise，proxy）；并且让JavaScript能适用于更大型的程序开发（modules、class）。更重要的是，这个规范会被浏览器，商、不同的平台广泛支持。

 实际上，所有的语言改进都是从使用者的最佳实践中提炼出来的。Javascript的约束一直很少，这一灵活性让开发者能相当自由地积累形形色色的使用经验和实践，也就是说，我们所有ECMAScript的使用者，也是其标准的间接贡献者。

# 第3版前言

4年前，当我开始写这本书的时候，ECMAScript 5.1版刚刚开始普及，最流行的框架还是jQuery。ES6看上去就像一个遥远的蓝图，无人知道何时会实现。

仅仅4年，ES6已经经历了ES2015，ES2016，ES2017这3个版本的迭代，各种实现的支持度已经超过90%，不仅可以实现网页的编写，还可以实现服务器脚本、手机App和桌面应用的编写。程序员们完全接受了这个标准，甚至大量使用尚未标准化的新语法。Javascript语言就像一列高铁，以令人“眩晕”的速度向前冲刺。

互联网行业的蓬勃兴旺造就了ES6的成功，也使得这本教程不断更新，越写越厚。第2版问世18个月之后，不得不推出第3版。

第3版新增了超过30%的内容，完全覆盖了ES2017标准（第2版只做到覆盖ES2015标准），并且对所有章节都进行了修订，文字表达更准确易懂，示例更丰富。对读者来说，这个版本更容易学习，更有参考价值。

这4年来，我对ES6的理解和所有的学习笔记，都浓缩在这本教程里面。那些我自己感到最困难的地方，书中都做出了详细讲解，给出了细致的示例，我相信这也是其他国内学习者所需要的。

这本教程当然也包含了些许局限，以及细致检查之后仍然疏漏的各种错误。一旦发现，我会第一时间更正。读者可以到官方仓库github.com/ruanyfles6tutorial中查看勘误。

我在微博上曾经说过一段话，就把它放在这里作为结束吧。

 “我水平其实不高，只是好奇心重，从没想到这么多人会关注。希望不要让大家失望，未来做一块垫脚石，为需要的朋友提供帮助，为技术的推广和发展做出力所能及的贡献。

# 第1版前言

2012年年底，我开始动手做一个开源项目《JavaScript标准参考教程》（github.com/ruanyf/jstutorial），原来的设想是将自己的学习笔记整理成一本书，哪里料到，这个项目不断膨胀，最后变成了ECMAScript5及其外围API的全面解读和参考手册，写了一年多还没写完。

那个项目的最后一章就是ECMAScript 6的语法简介。那一章也是越写越长，最后我不得不决定，把它独立出来，作为一个新项目，也就是您现在看到的这本书。

JavaScript已经是互联网开发的第一大语言，而且正在变成一种全领域的语言。著名程序员Jeff Atwood甚至提出了一条"Atwood定律"：“所有可以用JavaScript编写的程序，最终都会出现JavaScript的版本。"（Any application that can be written in JavaScript will eventually be written in JavaScript.）

ECMAScript正是JavaScript的国际标准，这就决定了该标准的重要性。而ECMAScript 6是ECMAScript历史上最大的一次版本升级，在语言的各个方面都有极大的变化，即使是熟练的JavaScript程序员，也需要重新学习。由于ES6的设计目标是企业级开发和大型项目，所以可以预料，除了互联网开发者，将来还会有大量应用程序开发者（甚至操作系统开发者）成为ES6的学习者。

我写作这本书的目标，就是想为上面这些学习者提供一本篇幅较短、简明易懂、符合中文表达习惯的ES6教程。它由浅入深、循序渐进，既有重要概念的讲解，又有API接口的罗列，便于日后当作参考手册查阅，还提供大量示例代码，让读者不仅一看就懂，还能举一反三，直接复制用于实际项目之中。

需要声明的是，为了突出重点，本书只涉及ES6与ES5的不同之处，不对JavaScript已有的语法进行全面讲解，毕竟市面上这样的教程已经有很多了。因此，本书不是JavaScript入门教材，不适合初学者。阅读本书之前，需要对JavaScript的基本语法有所了解。

我本人也是一个ES6的学习者，不敢说自己有多高的水平，只是较早地接触了这个主题，持续地读了许多资料，追踪标准的进展，做了详细的笔记而已。虽然我尽了最大努力，并且原稿在GitHub上公开后已经得到了大量的勘误，但是本书的不尽如人意之处恐怕还有不少。

欢迎大家访问本书的项目主页（**github.com/ruanyfles6tutorial**），提出意见，提交pull request这些都会包括在本书的下一个版本中。

# 第1章：ECMAScript6简介

ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已于2015年6月正式发布。它的目标是使JavaScript语言可以用于编写复杂的大型应用程序，成为**企业级开发语言**。

## ECMAScript与JavaScript的关系

一个常见的问题是，ECMAScript和JavaScript到底是什么关系？

要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布了262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。

该标准从一开始就是针对JavaScript语言制定的，但是并没有称其为JavaScript，主要有以下两方面原因。一是商标，Java是Sun公司的注册商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，而且JavaScript本身也已被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，而不是Netscape，这样有利于保证这门语言的开放性和中立性。

因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有JScript和ActionScript）。在日常场合，这两个词是可以互换的。

## ES6与ECMAScript2015的关系

ECMAScript 2015（简称ES2015）这个词也是经常可以看到的。那么，它与ES6是什么关系呢？

2011年，ECMAScript 5.1版本发布后，6.0版本便开始制定了。因此，ES6这个词的原意就是指，JavaScript语言的下一个版本。

由于这个版本引入的语法功能太多，而且在制定过程当中还有很多组织和个人不断提交新功能。因此，不可能在同一个版本里面包括所有将要引入的功能。常规的做法是先发布6.0版本，过一段时间再发布6.1版本，然后是6.2版本、6.3版本等。

但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。经过多次会议，如果一个提案足够成熟，便可以正式进入标准。也就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有所变动。

标准委员会最终决定，每年6月正式发布一次标准，作为当年的正式版本。接下来的时间就在这个版本的基础上进行改动，直到下一年的6月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。

ES6的第一个版本就这样在2015年6月发布了，正式名称是《ECMAScript 2015标准》（简称ES2015），2016年6月，小幅修订的《ECMAScript 2016标准》（简称ES2016）如期发布，这个版本可以看作是ES6.1版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上可以认为是同一个标准。根据计划，2017年6月会发布ES2017标准。

因此，ES6既是一个历史名词，也是一个泛指，含义是5.1版本以后的JavaScript的下一代标准，涵盖了ES2015、ES2016，ES2017等，而ES2015则是正式名称，特指当年发布的正式版本的语言标准。本书中提到的ES6，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言"。

## 语法提案的批准流程

任何人都可以向标准委员会（又称TC39委员会）提案，要求修改语言标准。

一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都要由TC39委员会批准。

* Stage 0：Strawman（展示阶段）

* Stage 1：Proposal（征求意见阶段）

* Stage 2：Draft（草案阶段）

* Stage 3：Candidate（候选阶段）

* Stage 4：Finished（定案阶段）

 一个提案只要能进入Stage 2，就基本认为其会包括在以后的正式标准里面。ECMAScript当前的所有提案都可以在TC39的官方网站Github.com/tc39/ecma262中查看。

本书的写作目标之一，是跟踪ECMAScript语言的最新进展，介绍5.1版本以后所有的新语法。对于那些明确或很有希望会被列入标准的新语法，本书都将予以介绍。

## ECMAScript的历史

ES6从开始制定到最后发布，整整用了15年。

前面提到，ECMAScript 1.0是1997年发布的，接下来的两年连续发布了ECMAScript 2.01998年6月）和ECMAScript 3.0（1999年12月），3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，它奠定了JavaScript语言的基本语法，被其后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学习3.0版的语法。

2000年，ECMAScript 4.0开始酝酿。这个版本最后没有通过，但其大部分内容被ES6所继承。因此，ES6制定的起点其实是在2000年。

为什么ES4没有通过呢？因为这个版本太激进了，对ES3做了彻底升级，导致标准委员会的一些成员不愿意接受.ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）
负责制订ECMAScript标准，成员包括Microsoft，Mozilla，Google等大公司。

2007年10月，ECMAScript 4.0版草案发布，本来预计次年8月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft.Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。

2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript5了。

2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39委员会的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能的加入，将由JavaScript.next完成。当时，JavaScript.next指的是ES6，第6版发布以后就指ES7，TC39的判断是，ES5会在2013年的年中成为JavaScript开发的主流标准，并在此后5年中一直保持这个位置。

2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262：2011）。

2013年3月，ECMAScript6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript
7中。

2013年12月，ECMAScript 6草案发布。此后是12个月的讨论期，以听取各方反馈意见。

2015年6月，ECMAScript 6正式通过，成为国际标准。从2000年算起，已经过去了15年。

（牛。。。。。。）

## 部署进度

关于各大浏览器最新版本对于ES6的支持，可以参阅kangax.github.io/es5-compat-table/es6/。随着时间的推移，支持度已经越来越高，超过90%的ES6语法特性都实现了。

Node是JavaScript语言的服务器运行环境（runtime），它对ES6的支持度更高。除了那些默认打开的功能，还有一些语法功能也已经实现了，但是默认没有打开。使用如下命令，可以查看Node中已经实现的ES6特性。

~~~
$ node --v8-options | grep harmony
~~~

![](读书笔记：ES6标准入门-第3版/01.png)

执行以上命令，输出结果会因为版本的不同而有所不同。

笔者写了一个ES-Checker（github.com/ruanyfles-checker）模块，用来检查各种运行环境对ES6的支持情况。访问ruanyf.github.ioles-checker即可查看所用浏览器对ES6的支持程度。运行下面的命令，可以查看本机对ES6的支持程度

~~~
$ npm install -g es-checker
$ es-checker
=============================
Passes 24 feature Dectations
Your runtime supports 57% of ECMAScript 6
=============================
~~~

![](读书笔记：ES6标准入门-第3版/02.png)

## Babel转码器

Babel（babeljs.io/）是一个广为使用的ES6转码器，可以将ES6代码转为ES5代码，从而在浏览器或其他环境执行。这意味着，可以用ES6的方式编写程序，而不用担心现有环境是否支持。下面是一个例子。

~~~javascript
//转码前
input.map（item => item + 1）;

//转码后
input.map（function（item）{
  return item +1;
});
~~~

上面的原始代码用了箭头函数，Babel将其转为普通函数，这样就能在不支持箭头函数的JavaScript环境中执行了。

下面的命令在项目目录中，安装 Babel。

~~~
$ npm install --save-dev @babel/core
~~~

### 配置文件`.babelrc`

Babel 的配置文件是`.babelrc`，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。

该文件用来设置转码规则和插件，基本格式如下。

~~~javascript
{
  "presets": [],
  "plugins": []
}
~~~

`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。

~~~javascript
# 最新转码规则
$ npm install --save-dev @babel/preset-env

# react 转码规则
$ npm install --save-dev @babel/preset-react

#不同阶段语法提案的转码规则（共有4个阶段），选装一个
$ npm install--save-dev babel-preset-stage-0
$ npm install--save-dev babel-preset-stage-1
$ npm install--save-dev babel-preset-stage-2
$ npm install--save-dev babel-preset-stage-3
~~~

然后，将这些规则加入`.babelrc`。

~~~javascript
  {
    "presets": [
      "@babel/env",
      "@babel/preset-react"
    ],
    "plugins": []
  }
~~~

注意，以下所有 Babel 工具和模块的使用，都必须先写好`.babelrc`。

### 命令行转码`babel-cli`

Babel 提供命令行工具`babel-cli`，用于命令行转码。

它的安装命令如下。

~~~javascript
$ npm install --global babel-cli
~~~

基本用法如下。

~~~json
# 转码结果输出到标准输出
$ npx babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ npx babel example.js --out-file compiled.js
# 或者
$ npx babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ npx babel src --out-dir lib
# 或者
$ npx babel src -d lib

# -s 参数生成source map文件
$ npx babel src -d lib -s
~~~

上面的代码是在全局环境下进行Babel转码的。这意味着，如果项目要运行，全局环境中必须有Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的Babel。

一个解决办法是将babel-c1i安装在项目之中，代码如下。

~~~javascript
#安装
$ npm install--save-dev babel-cli
~~~

然后，改写package.json。

~~~javascript
{
    // ...
    "devDependencies":{
		"babel-cli": "^6.0.0"
    },
	"scripts":{
		"build": "babel src -d lib"
    },
}
~~~

转码的时候需要执行以下命令。

~~~javascript
$ npm run build
~~~

### babel-node

`babel-cli`工具自带一个`babel-node`命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。

`babel-node`不用单独安装，而是随`babel-cli`一起安装。执行`babel-node`可以进入REPL环境。

~~~javascript
$ npx babel-node
> (x => x * 2)(1)
2
~~~

`babel-node`命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件`es6.js`，然后直接运行。

~~~javascript
# es6.js 的代码
# console.log((x => x * 2)(1));
$ npx babel-node es6.js
2
~~~

babel-node也可以安装在项目中。

~~~javascript
$ npm install--save-dev babel-cli
~~~

然后，改写package.json。

~~~json
{
	"scripts": {
		"script-name": "babel-node script.js"
    }
}
~~~

在以上代码中，使用babel-node替代node，这样script.js本身就不用进行任何转码处理了。

### babel-register 

`babel-register`模块改写了require命令，为它加上一个钩子。此后，每当使用require加载后缀为.js，.jsx..es和.es6的文件时，就会先用Babel进行转码。

~~~javascript
$ npm install --save-dev babel-register
~~~

使用时，必须首先加载babel-register。

~~~json
require("babel-register"); 
require ("./index. js");
~~~

这样便不需要手动对index.js进行转码了。

> `babel-register`只会对`require`命令加载的文件进行转码，而不会对当前文件进行转码。另外，由于它是实时转码，所以只适合在开发环境中使用。

### babel-core

(未完待续)

# 第2章：let和const命令

## let命令

### 基本用法

ES6新增了let命令，用于声明变量。其用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。

~~~javascript
{
  let a = 10; 
  var b = 1;
}
a 	 // ReferenceError: a is not defined.
b	  //  11
~~~

上面的代码在代码块中分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在其所在代码块内有效。

for循环的计数器就很适合使用let命令。

~~~javascript
for (let i = 0; i < 10; i++) {
  // ···
}
console.log(i);
//ReferenceError: i is not defined
~~~

以上代码中的计数器i只在for循环体内有效，在循环体外引用就会报错。

下面的代码如果使用var，最后将输出10.

~~~javascript
var a = []; 
for(var i = 0; i < 10; i++){
	a [i] = function ()
		console. log (i);
}; 
a[6](1);	//10
~~~

上面的代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量1。
每一次循环，变量1的值都会发生改变，而循环内，被赋给数组a的函数内部的console.1og（i）中的1指向全局的i。也就是说，所有数组a的成员中的i指向的都是同一个i，导致运行时输出的是最后一轮的i值，也就是10。

如果使用let，声明的变量仅在块级作用域内有效，最后将输出6。

~~~javascript
var a = []; 
for(let i = 0; i < 10; i++){
	a [i] = function ()
		console. log (i);
}; 
a[6](1);	//6
~~~

上面的代码中，变量i是let声明的，当前的i只在本轮循环有效。所以每一次循环的1.其实都是一个新的变量，于是最后输出的是6。大家可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值从而计算出本轮循环的值呢？这是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

~~~javascript
for (let i = 0; i< 3; i++) {
let i = ' abc'; 
console.log (i);
}

//abc
//abc
//abc
~~~

正确运行以上代码将输出3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，而是有各自单独的作用域。

### 不存在变量提升

var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。

为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则便会报错。

~~~javascript
//var的情况
console.log（foo）；//输出undefined 
var foo = 2；

//let的情况
console.log（bar）；//报错ReferenceError 
let bar =2；
~~~

在以上代码中，变量foo用var命令声明会发生变量提升，即脚本开始运行时，变量foo便已经存在，但是没有值，所以会输出undefined，变量bar用let命令声明则不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。

### 暂时性死区

只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

~~~javascript
var tmp =123;

if (true) {
 tmp = 'abc'; // ReferenceError 
 let tmp;
}
~~~

上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。

ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区"（temporal dead zone，简称TDZ）。

~~~javascript
if（true）{
//TDZ开始
tmp ='abc'；//ReferenceError 
console.log（tmp）；//ReferenceError 
  
let tmp；//TDZ结束
console.log（tmp）；//undefined 
  
tmp = 123；
console.log（tmp）；//123
}
~~~

上面的代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。

“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

~~~javascript
typeof x; //ReferenceError 
let x;
~~~

上面的代码中，变量x使用let命令声明，所以在声明之前都属于x的“死区"，只要用到该变量就会报错。因此，typeof运行时就会抛出一个Referencerror。

作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。

~~~javascript
typeof undeclared_variable // "undefined"
~~~

上面的代码中，undeclared-variable是一个不存在的变量名，结果返回"undefined".
所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就会报错。

有些“死区”比较隐蔽，不太容易发现。

~~~javascript
function bar（x=y，y=2）{
  return[x，y];
}
bar();		//报错
~~~

上面的代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x的默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已声明。

~~~javascript
function bar（x=2，y=x）{
  return[x，y];
}
bar();		//[2,2]
~~~

另外，下面的代码也会报错，与var的行为不同。

~~~javascript
//不报错
var x =x；

//报错
let x =x；
//ReferenceError：x is not defined
~~~

以上代码报错也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明前使用，就会报错。以上示例就属于这种情况，在变量×的声明语句还没有执行完成前就尝试获取×的值，导致出现"x未定义"的错误。

ES6规定暂时性死区和let，const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ESS中是很常见的，现在有了这种规定，避免此类错误就很容易了。

总之，暂时性死区的本质就是，只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

### 不允许重复声明

let不允许在相同作用域内重复声明同一个变量。

~~~javascript
//报错
function(){
	let a = 10;
  var a = 1；
}

//报错
function(){
	let a = 10;
  let a = 1;
}
~~~

因此，不能在函数内部重新声明参数。

~~~javascript
function func(arg){
  let arg;	//报错
}

function func(arg){
  {
    let arg;	//不报错
  }
}
~~~

## 块级作用域

### 为什么需要使用块级作用域

**ES5只有全局作用域和函数作用域，没有块级作用域**，这导致很多场景不合理。

第一种场景，**内层变量可能会覆盖外层变量**。

~~~javascript
var tmp = new Date();
console.log(tmp);     //Sat Apr 04 2020 14:59:42 GMT+0800 (中国标准时间)

function f() {
   console.log(tmp);
   if (false) {
       var tmp = 'hello world';
     //因为是false,所以tmp永远不会被赋值为hello world。
   }
}

f();   //undefined
~~~

以上代码的原意是，if代码块的外部使用**外层**的tmp变量，内部使用**内层**的tmp变量。
但是，函数 执行后，输出结果为undefined，原因在于**变量提升**导致**内层的tmp变量覆盖了外层的tmp变量**。

第二种场景，用来计数的**循环变量泄露为全局变量**。

~~~javascript
var s = 'hello';
for(var i = 0; i < s.length; i++){
  console.log(s[i])		//'o'
}
console.log(i);		//5

var animal = ['dog', 'cat', 'panda', 'tiger'];
for (var i = 0; i < animal.length; i++) {
      console.log(animal[i])   //dog cat panda tiger
}
console.log(i);		//4
~~~

上面的代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，而是**泄露**成了全局变量。

### ES6的块级作用域

let实际上为JavaScript新增了块级作用域。

~~~javascript
function f1() {
  let n = 5;
  if (true) {
     let n = 10;
  }
  console.log(n);   //5
}
f1();
~~~

上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示**外层代码块不受内层代码块的影响**。如果使用**var**定义变量n，最后输出的值就是10。

ES6允许块级作用域的**任意嵌套**。

~~~javascript
{{{{{let insane ='Hello world'}}}}};
~~~

上面的代码使用了一个5层的块级作用域。外层作用域无法读取内层作用域的变量。

~~~javascript
{{{{
  {let insane ='Hello world'}
  console.log(insane);	//报错
}}}};
~~~

内层作用域可以定义外层作用域的同名变量。

~~~javascript
{{{{
  let insane ='Hello world';
  {let insane ='Hello world'}
}}}};
~~~

**块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。**

~~~javascript
//IIFE写法
(function(){
  var tmp = ...;
  ...
}())

//块级作用域写法
{
  let tmp = ...;
  ...
}
~~~

### 块级作用域与函数声明

函数能不能在块级作用域之中声明？这是一个相当令人困惑的问题。

ES5规定，函数只能在顶层(全局)作用域和函数作用域之中声明，不能在块级作用域声明。

~~~javascript
//情况一
if(true){
	function f(){}
}

//情况二
try{
	function f(){}
}catch（e）{
    //...
}
~~~

上面两种函数声明在ES5中都是非法的。

但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际上都能运行，并不会报错。

ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，在块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

~~~javascript
function f(){console.log("I am outside")};
(function(){
    if(false){
        //重复声明一次函数f
        function f(){console.log("I am inside")}  
    }
    f();
})()
~~~

以上代码在ESS中运行会得到"I am inside！"，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。

> if(false){}那么大括号里的内容永远不会执行吧？？？？

~~~javascript
//ES5环境
function f(){console.log（'I am outside！'）;}

(function(){
	function f(){console.1og（'I am inside！');}
	if(false){      
    }
	f();
}());
~~~

而在ES6中运行就完全不一样了，理论上会得到"I am outside！"。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果真的在ES6浏览器中运行上面的代码，是会报错的，这是为什么呢？

原来，如果改变了块级作用域内声明的函数的处理规则，显然会对旧代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B（www.ecma-international.org/ecma-262/6.0/index.html#fsec-block-level-function-declarations-web-legacy-compatibility-semantics）中规定，浏览器的实现可以不遵守上面的规定，而有自己的行为方式（stackoverflow.com/questions/314 19897/what-are-the-precise-semantics-of-block-level-functions-in-es6），具体如下。

* 允许在块级作用域内声明函数。
* 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
* 同时，函数声明还会提升到所在的块级作用域的头部。

> 上面3条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，仍旧将块级作用域的函数声明当作let处理即可。

根据这3条规则，在浏览器的ES6环境中，块级作用域内声明函数的行为类似于var声明变量。

~~~javascript
//浏览器的ES6环境

~~~

第2章未完待续

# 第3章：变量的解构赋值

[es6之扩展运算符 三个点（...）](https://blog.csdn.net/astonishqft/article/details/82899965)

## 数组的解构赋值

### 基本用法

ES6允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构（Destructuring）。

以前，为变量赋值只能直接指定值。

~~~javascript
let a = 1;
let b = 2;
let c = 3;
~~~

ES6允许写成下面这样。

~~~javascript
let [a, b, c] =[1, 2, 3];
~~~

上面的代码表示，可以从数组中提取值，按照对应位置对变量赋值。

本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。

~~~javascript
let [foo, [[bar], baz]]= [1, [[2], 3]]; 
foo	 //1
bar	 //2
baz	 //3

let [,,third] = ["foo", "bar", "baz"];
third 	// "baz"

let [x,,y] = [1, 2, 3];
x	//1
y   //3

let [ head, ...tail] = [1, 2, 3, 4];
head //1
tail //[2, 3, 4]

let [x, y, ...z] = ['a'];
x 	//"a"
y 	//undefined
2	//[]
~~~

如果解构不成功，变量的值就等于undefined。

~~~javascript
let [foo] =[];
let [bar,foo] = [1];
~~~

以上两种情况都属于解构不成功，foo的值都会等于undefined。

另一种情况是不完全解构，即等号左边的模式只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

~~~javascript
let [x, y] =[1, 2, 3]; 
x	//1
y	//2

let [a, [b], d]= [1, [2, 3], 4];
a	//1
b	//2
d	//4
~~~

上面两个例子都属于不完全解构，但是可以成功。

如果**等号的右边不是数组**（或者严格来说不是可遍历的结构，参见第15章），那么将会报错。

~~~javascript
//报错
let[foo]=1;
let[foo]= false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] ={};
~~~

上面的语句都会报错，因为等号右边的值或是转为对象以后不具备Iterator接口（前五个表达式），或是本身就不具备Iterator接口（最后一个表达式）。

[iterator接口](https://blog.csdn.net/li1484155613/article/details/102171103)

对于Set结构，也可以使用数组的解构赋值。

~~~javascript
let [x, y, z]= new Set (['a', 'b', 'c');
x 	// "a"
~~~

事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。

~~~javascript
function* fibs(){
	let a =0;
    let b =1; 
    while (true){
		yield a;
		[a, b] =[b, a +b];
    }
}
let [first, second, third, fourth, fifth, sixth] = fibs();
sixth	//5
~~~

上面的代码中，fibs是一个Generator函数（参见第16章），原生具有Iterator接口。解松赋值会依次从这个接口中获取值。

## 对象的解构赋值

解构不仅可以用于数组，还可以用于对象。

~~~javascript
let { foo, bar } = { foo: "aaa", bar: "bbb" };
console.log(foo);			//"aaa"
console.log(bar);			//"bbb"
~~~

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值是由它的位置决定的；而**对象的属性没有次序**，**变量必须与属性同名**才能取到正确的值。

~~~javascript
let { bar, foo } = { foo: "aaa", bar: "bbb" };
console.log(foo);			//"aaa"
console.log(bar);			//"bbb"

let { baz } = { foo: "aaa", bar: "bbb" };
console.log(baz);     //undefined
~~~

上面代码的第一个例子中，等号左边的两个变量的次序与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。

如果**变量名与属性名不一致，必须写成下面这样**。

~~~javascript
let { foo: baz } = { foo: "aaa", bar: "bbb" };
console.log(baz);   //aaa

let obj = { first: "hello", last: "world" };
let { first: f, last: l } = obj;
console.log(f);    //"hello"
console.log(l);    //"world"
~~~

实际上说明，对象的解构赋值是下面形式的简写（参见第9章）。

~~~javascript
let{foo:foo,bar:bar} = {foo:"aaa",bar:"bbb"};
~~~

也就是说，对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者，而不是前者。

~~~javascript
let { foo: baz } = { foo: "aaa", bar: "bbb" };
console.log(baz);   //aaa
console.log(foo);   //foo is not defined
~~~

上面的代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。

# 第4章：字符串的扩展

ES6加强了对Unicode的支持，并且扩展了字符串对象。

## 字符的Unicode表示法

## codePointAt()

## String.fromCodePoint()

## 字符串的遍历器接口

ES6为字符串添加了遍历器接口（详见第15章），使得字符串可以由`for...of`循环遍历。

~~~javascript
for(let codePoint of 'foo'){
  console.log(codePoint);
}
//	"f"
//  "o"
//  "o"
~~~

除了遍历字符串，这个遍历器最大的优点是可以识别大于OxFFFF的码点，传统的for循环无法识别这样的码点。

## at()

## normalize()

## includes()、 startsWith()、endsWith() 

传统上，JavaScript中只有`indexOf`方法可用来确定一个字符串是否包含在另一个字符串中。ES6又提供了3种新方法。

* includes()：返回布尔值，表示是否找到了参数字符串。
* startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
* endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。

~~~javascript
var s = 'Hello world!';
s.startsWith ('Hello') 	//true 
s.endsWith ('!') 				//true
s.includes ('o') 				//true
~~~

这3个方法都支持第二个参数，表示开始搜索的位置。

~~~javascript
var s = 'Hello world!';
s.startsWith ('world',6) 	//true
s.endsWith ('Hello',5) 		//true
s.includes ('Hello',6) 	  //false
~~~

上面的代码表示，使用第二个参数n时，endswith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置到字符串结束位置之间的字符。

## repeat()

## padStart(), padEnd()

## 模版字符串

传统的JavaScript输出模板通常是这样写的。

![](读书笔记：ES6标准入门-第3版/05.png)

上面这种写法相当烦琐且不方便，ES6引入了模板字符串来解决这个问题。

![](读书笔记：ES6标准入门-第3版/06.png)

模板字符串（template string）是增强版的字符串，用反引号(`)标识。**它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量**。

![](读书笔记：ES6标准入门-第3版/07.png)

以上代码中的字符串都使用了反引号。如果在模板字符串中需要使用反引号，则在其前面要用反斜杠转义。

![](读书笔记：ES6标准入门-第3版/08.png)

如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出中。

![](读书笔记：ES6标准入门-第3版/09.png)

上面的代码中，所有模板字符串的空格和换行都是被保留的，比如`<ul>`标签前面会有一个换行。如果不想要这个换行，可以使用trim方法消除。

![](读书笔记：ES6标准入门-第3版/10.png)

在模板字符串中嵌入变量，需要将变量名写在`${ }`中。

![](读书笔记：ES6标准入门-第3版/11.png)

大括号内可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。

![](读书笔记：ES6标准入门-第3版/12.png)

模板字符串中还能调用函数。

![](读书笔记：ES6标准入门-第3版/13.png)

如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的tostring方法。

如果模板字符串中的变量没有声明，将报错。



​	

# 第7章：函数的扩展

## 函数参数的默认值

### 基本用法

在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。

~~~javascript
function log(x,y){
    y = y || 'world';
    console.log(x,y);
}

log ('Hello')				// Hello World
1og ('Hello', 'china') 		// Hello china 
log ('Hello', '')			// Hello world
~~~

上面的代码检查函数1og的参数y有没有赋值，如果没有，则指定默认值为world。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像以上代码的最后一行，参数y等于空字符，结果被改为默认值。

为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再令其等于默认值。

~~~javascript
if(typeof y === 'undefined'){
    y = 'World';
}
~~~

ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。

~~~javascript
function log(x, y= 'World'){
    console.log(x,y);
}

log ('Hello')				// Hello World
1og ('Hello', 'china') 		// Hello china 
log ('Hello', '')			// Hello 
~~~

可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。

~~~javascript
function Point(x = 0, y = 0){
    this.x = x;
    this.y = y;
}

var p = new Point();
p	//{x:0,y:0}
~~~

除了简洁，ES6的写法还有两个好处：首先，阅读代码的人可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本彻底拿掉这个参数，也不会导致以前的代码无法运行。

参数变量是默认声明的，所以不能用let或const再次声明。

~~~javascript
function foo(x = 5){
    let x = 1;		//error
    const x = 2;	//error
}
~~~

上面的代码中，参数变量x是默认声明的，在函数体中不能用let或const再次声明，否则会报错。

使用参数默认值时，函数不能有同名参数。

~~~javascript
function foo(x,x,y=1){
    //...
}

//SyntaxError: Duplicate parameter name not allowed in this context
~~~

另外一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。

~~~javascript
let x = 99;
function foo(p = x+1){
    console.log(p);
}
foo();		//100
x = 100;
foo();		//101
~~~

上面的代码中，参数p的默认值是x+1。这时，每次调用函数foo都会重新计算x+1，而不是默认p等于100。

### 与解构赋值默认值结合使用

参数默认值可以与解构赋值的默认值结合起来使用。

~~~javascript
function foo({x,y=5}{
     console.log(x,y);
}

foo({})				//undefined,5
foo({x:1})			//1,5
foo({x:1,y:2})		//1,2
foo()				//TypeError: Cannot read property 'x' of undefined
~~~

上面的代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量×和y就不会生成，从而报错。只有参数对象没有y属性时，y的默认值5才会生效。

下面是另一个对象的解构赋值默认值的例子。

~~~javascript
function fetch(url,{body='',method='GET',headers={}}){
    console.log(method);
}

fetch('http://example.com',{})
//'GET'

fetch('http://example.com')
//报错
~~~

上面的代码中，如果函数fetch的第二个参数是一个对象，就可以为它的3个属性设置默认值。

上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。

~~~javascript
function fetch(url,{method='GET'} = {}){
    console.log(method);
}

fetch('http://example.com',{})
//'GET'

~~~

上面的代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method取到默认值GET。

那么下面两种写法有什么差别呢？

~~~javascript
//写法一
function ml({x = 0,y = 0} = {}){
    return {x , y};
}

//写法二
function m2({x,y} = {x:0,y:0}){
    return {x , y}
}
~~~

上面两种写法都对函数的参数设定了默认值，区别在于，写法一中函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二中函数参数的默认值是一个有具体属性的函数，但是没有设置对象解构赋值的默认值。

~~~javascript
//函数没有参数的情况

m1（）	//[0，0]
m2（）	//[0，0]

//x和y都有值的情况
ml({x：3，y：8})	//[3，8]
m2({x：3，y：8})	//[3，8]

//x有值，y无值的情况
m1({x：3})		//[3，0]
m2({x：3})	   //[3，undefined]

//x和y都无值的情况
m1({})		//[0，0]；
m2({})		//[undefined，undefined]

m1({2：3})//[0，0]
m2({2：3})//[undefined，undefined]
~~~

### 参数默认值的位置

通常情况下，定义了默认值的参数应该是函数的尾参数。因为这样比较容易看出到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是无法省略的。

~~~javascript
//例一
function f(x=1,y){
    return [x , y];
}

f()				//[1，undefined]
f(2)  			//[2，undefined]）
f(,1)			//报错
f(undefined,1）	//[1，1]
  
//例二
function f(x，y = 5，z){
	return[x，y，z]；
}

f()					  //[undefined，5，undefined]
f(1)				  //[1，5，undefined]
f(1,,2）				 //报错
f(1，undefined，2)	//[1，5，2]
~~~

上面的代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数而不省略其后的参数，除非显式输入undefined。

如果传入undefined，将触发该参数等于默认值，null则没有这个效果。

~~~javascript
function foo(x = 5,y = 6){
    console.log(x , y);
}

foo(undefined , null)
//5 null
~~~

上面的代码中，x参数对应undefined，结果触发了默认值，y参数等于null，没有触发默认值。

### 函数的length属性

指定了默认值以后，函数的length属性将返回没有指定默认值的参数个数。也就是说，**指定了默认值后，length属性将失真**。

~~~javascript
(function (a){}).length 	 			//1
(function (a = 5){}).length  			//0
(function (a, b, c = 5){}).length 		//2
~~~

上面的代码中，length属性的返回值等于函数的参数个数减去指定了默认值的参数个数。比如，上面的最后一个函数定义了3个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，即2。

这是因为length属性的含义是该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性。

~~~javascript
(function(... args){}).length 		//0
~~~

如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数。

如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数。

~~~javascript
(function(a = 0,b,c){}).length		//0
(function(a,b = 1,c){}).length		//1
~~~

### 作用域

## 箭头函数

### 基本用法

ES6允许使用“箭头”（=>）定义函数。

~~~javascript
var f = v => v;
~~~

上面的箭头函数等同于以下代码：

~~~javascript
var f = function(v){
    return v;
};
~~~

如果箭头函数**不需要参数或需要多个参数**，就**使用圆括号**代表参数部分。

~~~javascript
var f = () => 5;

//等同于

var f = function(){
    return 5;
};
~~~

~~~javascript
var sum = (num1,num2) => num1 + num2;

//等同于

var sum = function(num1,num2){
    return num1 + num2;
};
~~~

如果箭头函数的**代码块部分多于一条语句**，就要使用大括号将其括起来，并使用return语句返回。

~~~javascript
var sum  = (num1,num2) => {
    return num1 + num2;
};
~~~

由于大括号被解释为代码块，所以**如果箭头函数直接返回一个对象**，**必须在对象外面加上括号**。

~~~javascript
var getTempItem = id => ({
    id:id,
    name: 'Temp'
});
~~~

箭头函数可以与变量解构结合使用。

~~~javascript
const full = ({first,last}) => first + ' ' + last;

//等同于

function full(person){
    return person.first + ' ' + person.last;
}
~~~

箭头函数使得表达更加简洁。

~~~javascript
const isEven = n => n % 2 == 0;
const square = n => n * n;
~~~

上面的代码只用了两行就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。

箭头函数的一个用处是简化回调函数。

~~~javascript
//正常函数写法
[1,2,3].map(function(x){
    return x * x;
});

//箭头函数写法
[1,2.3].map(x => x * x);
~~~

下面是另一个例子：

~~~javascript
//正常函数写法
var result = values.sort(function(a,b){
    return a - b;
});
//箭头函数写法
var result = values.sort((a,b) => a - b);
~~~

下面是rest参数与箭头函数结合的例子。

~~~javascript
const numbers = (...nums) => nums;

numbers(1,2,3,4,5)
//[1,2,3,4,5]

const headAndTail = (head, ...tail) => [head,tail];

headAndTail(1,2,3,4,5)
//[1,[2,,3,4,5]]
~~~

### 注意事项

箭头函数有以下几个使用注意事项。

* 函数体内的this对象**就是定义时**所在的对象，而**不是使用时**所在的对象。
* 不可以当作构造函数。也就是说，不可以使用new命令，否则会抛出一个错误。
* 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。

* 不可以使用yield命令，因此箭头函数不能用作**Generator**函数。

其中，第一点尤其值得注意。**this对象的指向是可变的，但在箭头函数中它是固定的**。

~~~javascript
function foo(){
    setTimeout(() =>{
        console.log('id:',this.id)
    },3000);
}

var id = 21;

foo.call({id:42});

//id:42
~~~

上面的代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义是在foo函数生成时生效的，而它真正执行要等到100ms后。**如果是普通函数，执行时this应该指向全局对象window**，这时应该输出21，但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是（id：42）），所以输出的是42。

> setTimeout函数中的this是指向window的。

箭头函数可以让setTimeout里面的this绑定**定义时**所在的作用域，而**不是**指向**运行时**所在的作用域。下面是另一个例子。

~~~javascript
function Timer(){
    this.s1 = 0;
    this.s2 = 0;
    //箭头函数
    setInterval(() => this.s1++,1000);
    
    //普通函数
    setInterval(function(){
        this.s2++;
    },1000)
}

var timer = new Timer();

setTimeout(() => console.log('s1:',timer.s1),3100);
setTimeout(() => console.log('s2:',timer.s2),3100);

//s1:3
//s2:0
~~~

上面的代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象），所以，3100ms之后，`timer.s1`被更新了3次，而`timer.s2`一次都没更新。

> 没看懂。。。

**箭头函数可以让this指向固定化，这种特性非常有利于封装回调函数**。下面是一个例子，DOM事件的回调函数封装在一个对象里面。

~~~javascript
var handler = {
    id:'123456',
    init:function(){
        document.addEventListener('click',event =>this.doSomething(event.type),false);
    },
    doSomething:function(type){
        console.log('Handling' + type + 'for' + this.id);
    }
};
~~~

以上代码的init方法中使用了箭头函数，这导致箭头函数里面的this总是指向handler对象。否则，回调函数运行时，this.doSomething一行会报错，因为此时thig指向document对象。

this指向的固定化并不是因为箭头函数内部有绑定this的机制，实际原因是**箭头函数根本没有自己的this**，导致内部的this就是外层代码块的this。正是因为它没有this，所以不能用作构造函数。

箭头函数转成ES5的代码如下。

~~~javascript
//ES6
function foo(){
    setTimeout(() =>{
        console.log('id:',this.id);
    },1000)
}

//ES5
function foo(){
    var _this = this;
    setTimeout(function(){
        console.log('id:',_this.id);
    },1000)
}
~~~

上面的代码中，转换后的ES5版本清楚地说明了箭头函数里面根本没有自己的this，而是引用外层的this。

请问下面的代码之中有几个this？

~~~javascript
function foo(){
    return () =>{
        return () =>{
             return () =>{
             	console.log('id:',this.id);
        	 };
        };
    };
}

var f = foo.call ((id: 1)); 

var tl = f.call({id: 2})()(); 	//id: 1
var t2 = f().call({id: 3})(); 	//id: 1
var t3 = f()().call({id:4}); 	//id: 1
~~~

> 代码看不懂。

上面的代码中只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。

除了this，以下3个变量在箭头函数中也是不存在的，分别指向外层函数的对应变量：`arguments`，`super`和`new.target`。

~~~javascript
function foo(){
    setTimeout(() => {
        console.log('args',arguments)
    },1000);
}

foo(2,4,6,8)
//args:[2,4,6,8]
~~~

上面的代码中，箭头函数内部的变量arguments其实是函数foo的arguments变量。

另外，由于箭头函数没有自己的this，当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变this的指向。

~~~javascript
(function(){
	return {
        (() => this.x).bind({x:'inner'})()
    };
}).call({x:'outer'});

//['outer']
~~~

> 代码看不懂

上面的代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。

长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this必须非常小心。箭头函数“绑定”this，很大程度上解决了这个困扰。

# 第9章：对象的扩展

## 属性的简洁表示法

ES6允许直接写入变量和函数作为对象的属性和方法。这样的书写更加简洁。

~~~javascript
var foo = 'bar';
var baz = {foo};
baz			//{foo:"bar"}
~~~

等同于

~~~javascript
var baz = {foo:foo}
~~~

上面的代码表明，ES6允许在对象中只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。下面是另一个例子。

~~~javascript
function f(x,y){
  return (x,y);
}
~~~

等同于

~~~javascript
function f(x,y){
  return {x:x,y:y}
}
f(1,2)		//Object{x:1,y:2}
~~~

除了属性简5，方法也可以简写。

~~~javascript
var o = {
  method(){
    return "Hello!";
  }
};
~~~

等同于

~~~javascript
var o = {
  method:function(){
    return "Hello!";
  }
};
~~~

下面是一个实际的例子。

~~~javascript

~~~



# 第10章：Symbol

[谈谈我对ES6 Symbol的理解](https://zhuanlan.zhihu.com/p/183874695)

## 概述

ES5的对象**属性名都是字符串**，这容易造成属性名的冲突。比如，我们使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），**新方法的名字就有可能与现有方法产生冲突**。如果有一种机制，能够**保证每个属性的名字都是独一无二的就好了**，这样就能**从根本上防止属性名冲突**。这就是ES6引入类型Symbol的原因。

ES6引入了一种新的原始数据类型Symbo1，表示独一无二的值。它是JavaScript语言的**第7种**数据类型，前6种分别是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）和对象（Object）。

Symbol值通过**Symbol函数**生成。也就是说，**对象的属性名现在可以有两种类型**：**一种是原来就有的字符串，另一种就是新增的Symbol类型**。只要属性名属于Symbol类型，就是独一无二的，可以保证不会与其他属性名产生冲突。

~~~javascript
lets=Symbol();

typeof s
//"symbol"
~~~

上面的代码中，**变量s就是一个独一无二的值**。typeof运算符的结果表明变量s是Symbol数据类型，而不是字符串之类的其他类型。

![](读书笔记：ES6标准入门-第3版/03.png)

Symbol函数可以接受一个字符串作为参数，**表示对Symbol实例的描述**，**主要是为了在控制台显示**，或者转为字符串时比较**容易区分**。

~~~javascript
var s1=Symbol('foo'); 
var s2=Symbol('bar');

s1	//Symbol(foo)
s2	//Symbol(bar)

s1.toString()	//"symbol(foo)"
s2.tostring()	//"Symbol(bar)"
~~~

上面的代码中，s1和s2是两个Symbol值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。**有了参数以后，就等于为它们加上了描述，输出时就能够分清到底是哪一个值**。

如果Symbol的**参数是一个对象**，就会调用该对象的toString方法，将其转为字符串，然后才生成一个Symbol值。

~~~javascript
const obj={
    toString(){
		return 'abc';
    }
};
const sym=Symbol(obj); 
sym		//Symbol(abc)
~~~

![](读书笔记：ES6标准入门-第3版/04.png)

~~~javascript
//没有参数的情况
var sl = Symbol()；
var s2 = Symbol()；
s1 === s2		//false

//有参数的情况
var s1 = Symbol('foo')；
var s2 = Symbol('foo');
s1 === s2		//false
~~~

上面的代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。

Symbol值不能与其他类型的值进行运算，否则会报错。

~~~javascript
var sym = Symbol ('My symbol');
"your symbol is "+ sym;
// TypeError: can't convert symbol to string 

your symbol is ${sym}
// TypeError: can't convert symbol to string
~~~

但是，Symbol值可以显式转为字符串。

~~~javascript
var sym = Symbol (' My symbol');
string (sym) 	//'Symbol (My symbol)'
sym.toString()	//'Symbol (My symbol)'
~~~

另外，Symbol值也可以转为布尔值，但是不能转为数值。

~~~javascript
var sym =Symbol();
Boolean (sym) 	//true
!sym 	//false 
if (sym){
    //...
}

Number (sym); // TypeError 
sym + 2;	 // TypeError
~~~

## 作为属性名的Symbol

由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符用于对象的属性名，保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

~~~javascript
var mysymbol = Symbol()；

//第一种写法
var a ={}；
a[mySymbol]='Hello!';

//第二种写法
var a = {
	[mySymbol]：'Hello!'
};

//第三种写法
var a = {};
Oject.defineProperty(a，mySymbol，{value：'Hello！'})；

//以上写法都得到同样结果
a[mySymbol]		//"Hello！"
~~~

上面的代码通过方括号结构和object.defineProperty将对象的属性名指定为一个Symbol值。

注意，Symbol值作为对象属性名时**不能使用点运算符**。

~~~javascript
var mysymbol = Symbol(); 
var a = {};
a.mySymbol = 'Hello!';
a[mySymbol]	 //undefined
a['mysymbol'] 	//"Hello!"
~~~

上面的代码中，因为点运算符后面总是字符串，所以不会读取mysymbo1作为标识名所指代的值，导致a的属性名实际上是一个字符串，而不是一个Symbol值。

同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号中。

~~~javascript
let s = Symbol();
let obj = {
    [s]:function(arg)(···)
};
obj[s](123);
~~~

上面的代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的Symbol值。

采用增强的对象写法，上面的obj对象可以写得更简洁一些。

~~~javascript
let obj = {
    [s](arg )(···)
};
~~~

Symbol类型还可用于定义一组常量，保证这组常量的值都是不相等的。

~~~javascript
log.levels = {
    DEBUG: Symbol ('debug'),
    INFO: Symbol ('info'),
    WARN: Symbol ('warn')
}; 

log(log.levels.DEBUG,'debug message');
log(log.levels.INFO,'info message');
~~~

下面是另外一个例子。

~~~javascript
const COLOR_RED = Symbol();
const COLOR_GREEN = Symbol(); 

function getComplement (color) {
  switch (color){
     case COLOR RED: 
      	return COLOR GREEN; 
     case COLOR GREEN:
        return COLOR RED; 
 	default: 
       throw new Error('Undefined color');
   }
}
~~~

常量使用Symbol值的最大好处就是，其他任何值都不可能有相同的值了，因此可以保证上面的switch语句按设计的方式工作。

> Symbol值作为属性名时，该属性还是公开属性，不是私有属性。

## 实例：消除魔术字符串

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或数值。风格良好的代码，应该尽量消除魔术字符串，而由含义清晰的变量代替。

~~~javascript
function getArea(shape,options){
    var area = 0;
    switch(shape){
        case 'Triangle':  //魔术字符串
        area = .5 * options.width * options.height;
        break;
        /*...more code...*/
    }
    return area;
}

getArea('Triangle',{width:100,height:100});		//魔术字符串
~~~

上面的代码中，字符串，Triangle'就是一个魔术字符串。它多次出现，与代码形成“强耦合"，不利于将来的修改和维护。

常用的消除魔术字符串的方法，就是把它写成一个变量。

~~~javascript
var shapeType= {
    triangle: 'Triangle'
};

function getArea(shape,options){
    var area = 0;
    switch(shape){
        case shapeType.triangle:  
        area = .5 * options.width * options.height;
        break;
        /*...more code...*/
    }
    return area;
}

getArea(shapeType.triangle,{width:100,height:100});		//魔术字符串
~~~

上面的代码中，我们把'rriangle'写成shapeType对象的triangle属性，这样就消除了强耦合。

如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会和其他shaperype属性的值冲突即可。因此，这里就很适合改用Symbol值。

~~~javascript
const shapeType = {
    triangle:Symbol()
};
~~~

上面的代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改。

## 属性名的遍历

# 第11章：Set和Map数据结构

[ ES6 Map 与 Set](https://www.runoob.com/w3cnote/es6-map-set.html)

## Set

[数据结构之集合Set](https://www.cnblogs.com/biehongli/p/12487717.html)

### 基本用法

ES6提供了新的数据结构——Set。它类似于数组，但是**成员的值都是唯一的，没有重复**。

> 我记得很清楚，set的中文有集合的意思，实际上它就是我们高中学过的集合。

Set**本身是一个构造函数**，用来生成Set数据结构。

[JS中forEach的用法](https://www.cnblogs.com/Joe-and-Joan/p/10079466.html)

[for in 和for of的区别](https://www.jianshu.com/p/c43f418d6bf0)

> `for in`更适合遍历对象(key),`for of`更适合遍历数组(value)。

~~~javascript
const s = new Set();
[2,3,5,4,5,2,2].forEach(x=>s.add(x));

for(let i of s){
    console.log(i);
}
~~~

上面的代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。

Set函数可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数，用来初始化。

~~~javascript
//例一
const set = new Set([1,2,3,4,4]);
[...set]
//[1,2,3,4]

//例二
const items = new Set([1,2,3,4,5,5,5,5]);
items.size		//5

//例三
function divs(){
    return [...document.querySelectorAll('div')];
}

const set = new Set(divs());
set.size		//56

//类似于
divs().forEach(div => set.add(div));
set.size;		//56
~~~

上面的代码中，例一和例二是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。

上面的代码中也展示了一种去除数组重复成员的方法。

~~~javascript
//去除数组的重复成员
[...new Set(array)]
~~~

向Set加入值时不会发生类型转换，所以5和"5"是两个不同的值。Set内部判断两个值是否相同时使用的算法叫作`“Same-value equalit"`，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。

~~~javascript
let set = new Set ();
let a = NaN; 
let b = NaN;
set.add (a);
set.add (b);
set 	//Set (NaN)
~~~

上面的代码向Set实例添加了两个NaN，但是实际上只能添加一个。这表明，在Set内部，两个NaN是相等的。

另外，两个对象总是不相等的。

~~~javascript
let set = new Set();
set.add({});
set.size	//1

set.add({});	
set.size	//2
~~~

上面的代码表示，由于两个空对象不是精确相等，所以它们被视为两个值。

## WeakSet

## Map

### 含义和基本用法

JavaScript的对象（Object）本质上是键值对的集合（Hash结构），但是**只能用字符串作为键**。这给它的使用带来了很大的限制。

~~~javascript
const data = {};
const element = document.getElementById('myDiv');
data[element] = 'metadata';
data['[object HTMLDivElement]']		//'metadata'
~~~

上面的代码原意是将一个DOM节点作为对象data的键，但是**由于对象只接受字符串作为键名**，所以element被自动转为字符串`[object HTMIDivElement]`。

为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串一值”的对应，Map结构提供了“值一值”的对应，是一种更完善的Hash结构实现。如果需要“键值对”的数据结构，Map比Object更合适。

~~~javascript
const m = new Map();
const o = {p:'Hello World'};

m.set(o,'content')
m.get(o)	//'content'

m.has(o)		//true
m.delete(o)		//true
m.has(o)		//false
~~~

上面的代码使用Map结构的set方法，**将对象o当作m的一个键**，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。

上面的例子展示了如何向Map添加成员。作为**构造函数**，**Map也可以接受一个数组作为参数**。该数组的成员是一个个表示键值对的数组。

~~~javascript
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
~~~

上面代码在新建 Map 实例时，就指定了两个键`name`和`title`。`Map`构造函数接受数组作为参数，实际上执行的是下面的算法。

~~~javascript
const items = [
  ['name', '张三'],
  ['title', 'Author']
];

const map = new Map();

items.forEach(
  ([key, value]) => map.set(key, value)
);
~~~

事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数。这就是说，`Set`和`Map`都可以用来生成新的 Map。

~~~javascript
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
~~~

上面代码中，我们分别使用 Set 对象和 Map 对象，当作`Map`构造函数的参数，结果都生成了新的 Map 对象。

如果对同一个键多次赋值，后面的值将覆盖前面的值。

~~~javascript
const map = new Map();

map
.set(1, 'aaa')
.set(1, 'bbb');

map.get(1) // "bbb"
~~~

上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。

如果读取一个未知的键，则返回`undefined`。

~~~javascript
new Map().get('asfddfsasadf')
// undefined
~~~

注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

~~~javascript
const map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined
~~~

上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。

同理，同样的值的两个实例，在 Map 结构中被视为两个键。

~~~javascript
const map = new Map();

const k1 = ['a'];
const k2 = ['a'];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
~~~

上面代码中，变量`k1`和`k2`的值是一样的，但是它们在 Map 结构中被视为两个键。

由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。

~~~javascript
let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
~~~

### 实例的属性和操作方法

Map 结构的实例有以下属性和操作方法。

#### size属性

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size // 2
```

#### Map.prototype.set(key, value)

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set('edition', 6)        // 键是字符串
m.set(262, 'standard')     // 键是数值
m.set(undefined, 'nah')    // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');
```

#### **Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function() {console.log('hello');};
m.set(hello, 'Hello ES6!') // 键是函数

m.get(hello)  // Hello ES6!
```

#### **Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set('edition', 6);
m.set(262, 'standard');
m.set(undefined, 'nah');

m.has('edition')     // true
m.has('years')       // false
m.has(262)           // true
m.has(undefined)     // true
```

#### **Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, 'nah');
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
```

#### **Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size // 2
map.clear()
map.size // 0
```



# 第12章：Proxy

[怎么理解元编程？](https://www.zhihu.com/question/23856985)

[ES6 proxy浅析](https://zhuanlan.zhihu.com/p/96693941)

[ES6系列之Proxy](http://blog.poetries.top/2018/12/21/es6-proxy/)

## 概述

Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（`meta programming`），即对编程语言进行编程。

Proxy可以理解成在目标对象前架设一个“拦截”层，外界对该对象的访问都必须先通过这层拦截，因此提供了一种机制可以对外界的访问进行**过滤和改写**。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

~~~javascript
var obj = new Proxy({},{
    get:function(target,key,receiver){
        console.log(`getting ${key}!`);
        return Reflect.get(target,key,receiver);
    },
    set:function(target,key,value,receiver){
        console.log(`setting ${key}!`);
        return Reflect.set(target,key,value,receiver);
    }
});
~~~

上面的代码对一个空对象进行了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。读取设置了拦截行为的对象obj的属性就会得到下面的结果。

~~~javascript
obj.count = 1;
//setting count!
++obj.count
//getting count!
//getting count!
//2
~~~

上面的代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。

ES6原生提供Proxy构造函数，用于生成Proxy实例。

~~~javascript
var proxy = new Proxy(target,handler);
~~~

Proxy对象的所有用法都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

下面是另一个拦截读取属性行为的例子。

~~~javascript
var proxy = new Proxy({},{
    get:function(target,property){
        return 35;
    }
});

proxy.time		//35
proxy.name		//35
proxy.title		//35
~~~

上面的代码中，构造函数Proxy接受两个参数；第一个参数是所要代理的目标对象（上例中是一个空对象），即如果没有Proxy介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面的代码中，配置对象有一个get方法用来拦截对目标对象属性的访问请求。

get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都将得到35。

> 要使Proxy起作用，必须针对Proxy实例（上例中是proxy对象）进行操作，而不是针对目标对象（上例中是空对象）进行操作。

# 第14章：Promise对象

## Promise的含义

[这是一篇傻瓜都能看懂的Promises文章！](https://zhuanlan.zhihu.com/p/24684803)

[10分钟理解JS异步编程（从概念到原理）](https://juejin.im/post/6844903889477566471)

Promise是**异步编程**的一种解决方案，比传统的解决方案——回调函数和事件——更合理 且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了 用法，并原生提供了Promise对象。

所谓Promise，简单来说就是一个**容器**，里面保存着某个**未来才会结束的事件**（通常是一个异步操作）的结果。从语法上来说，Promise是-一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。

Promise对象有以下两个特点。

* **对象的状态不受外界影响**。Promise 对象代表一个异步操作，有3种状态：**pending（进行中）**、**fulfilled（已成功）**和**rejected（已失败）**。只有异步操作的**结果**，可以决定当前是哪一种状态，**任何其他操作都无法改变这个状态**。这也是“Promise”这个名字的由来，它在英语中意思就是“承诺”，表示其他手段无法改变。

* **一旦状态改变就不会再变，任何时候都可以得到这个结果**。Promise对象的状态改变**只有两种可能**：**从pending变为fulfilled和从pending变为rejected**。只要这两种情况发生，状态就凝固了，不会再变，而是一直保持这个结果，这时就称为**resolved（已定型）**。就算改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同。**事件的特点是，如果错过了它，再去监听是得不到结果的**。

注意，为了行文方便，本章后面的resolved统一指fulilled 状态，不包含rejected状态。

有了Promise对象，就可以**将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数**。此外，Promise对象提供**统一的接口**，使得控制异步操作更加容易。

Promise也有一些缺点。**首先**，无法取消Promise，一旦新建它就会立即执行，无法中途取消。**其次**，如果不设置回调函数，Promise内部抛出的错误不会反应到外部。**再者**，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

如果某些事件不断地反复发生，一般来说，使用[Stream 模式](https://nodejs.org/api/stream.html)是比部署Promise更好的选择。

## 基本用法

ES6规定，Promise对象是一个构造函数，用来生成Promise实例。

下面的代码创造了一个Promise实例。

~~~javascript
const promise = new Promise(function(resolve,reject){
    //...some code
    
    if(/*异步操作成功*/){
       resolve(value);
    }else{
       reject(error);
    }
})
~~~

Promise构造函数**接受一个函数作为参数**，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。

**resolve函数的作用是**，将Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果作为参数传递出去；**reject函数的作用是**，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。

Promise 实例生成以后，可以**用`then`方法分别指定resolved 状态和rejected状态的回调函数**。

~~~javascript
Promise.then(function(value){
    //success
},function(error){
    //failure
});
~~~

**`then`方法可以接受两个回调函数作为参数**。**第一个回调函数**是Promise对象的状态变为resolved 时调用，**第二个回调函数**是Promise对象的状态变为rejected时调用。其中，**第二个函数是可选的，不一定要提供**。这两个函数都接受Promise对象传出的值作为参数。

下面是一个Promise对象的简单例子。

~~~javascript
function timeout(ms){
    return new Promise((resolve,reject)=>{
        setTimeout(resolve,ms,'done');
    });
}

timeout(100).then((value)=>{
    console.log(value);
});
~~~

> 我去，这个代码看不懂。

上面的代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。

过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。

Promise新建后就会立即执行。

~~~javascript
let promise = new Promise(function(resolve,reject){
    conosle.log('Promise');
    resolve();
});

promise.then(function(){
    console.log('Resolved.');
});

console.log('Hi');

//Promise
//Hi!
//Resolved
~~~

上面的代码中，**Promise新建后会立即执行，所以首先输出的是Promise**。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完成后才会执行，所以Resolved最后输出。

下面是异步加载图片的例子。

[用Image对象加载的图片怎么放到页面中去？](https://segmentfault.com/q/1010000004504761)

~~~javascript
function loadImageAsync(url){
    return new Promise(function(resolve,reject){
        var image = new Image();
        
        image.onload = function(){
            resolve(image);
        };
        
        image.onerror = function(){
            reject(new Error('could not load image at' + url))
        };
        
        img.src = url;
    });
}
~~~

上面的代码中使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。

下面是一个用Promise对象实现的AJAX操作的例子。

~~~javascript
const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    client.send();

  });

  return promise;
};

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
~~~

上面代码中，`getJSON`是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个`Promise`对象。需要注意的是，在`getJSON`内部，`resolve`函数和`reject`函数调用时，都带有参数。

如果调用`resolve`函数和`reject`函数时带有参数，那么它们的参数会被传递给回调函数。`reject`函数的参数通常是`Error`对象的实例，表示抛出的错误；`resolve`函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。

~~~javascript
const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
~~~

上面代码中，`p1`和`p2`都是 Promise 的实例，但是`p2`的`resolve`方法将`p1`作为参数，即一个异步操作的结果是返回另一个异步操作。

注意，这时`p1`的状态就会传递给`p2`，也就是说，`p1`的状态决定了`p2`的状态。如果`p1`的状态是`pending`，那么`p2`的回调函数就会等待`p1`的状态改变；如果`p1`的状态已经是`resolved`或者`rejected`，那么`p2`的回调函数将会立刻执行。

~~~javascript
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// Error: fail
~~~

> 这个也看不懂

上面代码中，`p1`是一个 Promise，3 秒之后变为`rejected`。`p2`的状态在 1 秒之后改变，`resolve`方法返回的是`p1`。由于`p2`返回的是另一个 Promise，导致`p2`自己的状态无效了，由`p1`的状态决定`p2`的状态。所以，后面的`then`语句都变成针对后者（`p1`）。又过了 2 秒，`p1`变为`rejected`，导致触发`catch`方法指定的回调函数。

注意，调用`resolve`或`reject`并不会终结 Promise 的参数函数的执行。

```javascript
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1
```

上面代码中，调用`resolve(1)`以后，后面的`console.log(2)`还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。

一般来说，调用`resolve`或`reject`以后，Promise 的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。

```javascript
new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
```

## Promise.prototype.then()

Promise 实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。

`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。

```javascript
getJSON("/posts.json").then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
```

上面的代码使用`then`方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。

采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这时后一个回调函数，就会等待该`Promise`对象的状态发生变化，才会被调用。

```javascript
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function (comments) {
  console.log("resolved: ", comments);
}, function (err){
  console.log("rejected: ", err);
});
```

上面代码中，第一个`then`方法指定的回调函数，返回的是另一个`Promise`对象。这时，第二个`then`方法指定的回调函数，就会等待这个新的`Promise`对象状态发生变化。如果变为`resolved`，就调用第一个回调函数，如果状态变为`rejected`，就调用第二个回调函数。

如果采用箭头函数，上面的代码可以写得更简洁。

~~~javascript
getJSON("/post/1.json").then(
  post => getJSON(post.commentURL)
).then(
  comments => console.log("resolved: ", comments),
  err => console.log("rejected: ", err)
);
~~~

## Promise.prototype.catch()



# 第15章：Iterator和for...of循环

## lterator（遍历器）的概念

JavaScript原有的表示“集合”的数据结构主要是**数组**（Array）和**对象**（Object），ES6又添加了**Map**和**Set**。这样就有了4种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制来处理所有不同的数据结构。

# 第22章：Module的语法

## 概述

JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法将它们拼装起来。其他语言都有这项功能，比如Ruby的`require`，Python的`import`，甚至连CSS都有`@import`，但是JavaScript没有任何对这方面的支持，这对于开发大型、复杂的项目而言是一个巨大的障碍。

在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。

ES6模块的设计思想是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块都只能在运行时确定这些东西。比如，**CommonJS模块就是对象**，输入时必须查找对象属性。

~~~javascript
//CommonJS模块
let{stat，exists，readFile} = require('FS');

//等同于
let _fs = require('fs'); 
let stat = _fs.stat; 
let exists = _fs.exists;
let readfile  = _fs.readfile;
~~~

上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时进行“静态优化"。

**ES6模块不是对象**，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。

~~~javascript
//ES6模块
import {stat，exists，readFile} from 'fs';
~~~

上面代码的实质是从fs模块加载3个方法，而不加载其他方法。这种加载称为“编译时加载”或者静态加载，即ES6可以在编译时就完成模块加载，效率比CommonJS模块的加载方式高。当然，这也导致了ES6模块本身无法被引用，因为它不是对象。

由于**ES6模块是编译时加载，使得静态分析成为可能**。有了它就能进一步拓展JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。

除了静态加载带来的各种好处，ES6模块还有以下好处。

* 不再需要UMD模块格式，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库其实已经做到了这一点。
* 将来浏览器的新API可以用模块格式提供，不再需要做成全局变量或者navigator对象的属性。
* 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块来提供。

本章介绍ES6模块的语法，下一章将介绍如何在浏览器和Node之中加载ES6模块。

## 严格模式

ES6的模块自动采用严格模式，不管有没有在模块头部加上`"use strict"`。

严格模式主要有以下限制。

* 变量必须声明后再使用。
* 函数的参数不能有同名属性，否则报错。
* 不能使用with语句。
* 不能对只读属性赋值，否则报错。
* 不能使用前缀0表示八进制数，否则报错。
* 不能删除不可删除的属性，否则报错。
* 不能删除变量delete prop，会报错，只能删除属性delete global[prop]
* eval不会在它的外层作用域引入变量。
* eval和arguments不能被重新赋值。
* arguments不会自动反映函数参数的变化。
* 不能使用arguments.callee。
* 不能使用arguments.caller。
* 禁止this指向全局对象。
* 不能使用fn.caller和fn.arguments获取函数调用的堆栈。
* 增加了保留字（比如protected.static和interface）。

上面这些限制，模块都必须遵守。由于严格模式是ES5引入的，不属于ES6，所以请参阅相关的ES5书籍，本书不再详细介绍。

> 尤其需要注意this的限制。在ES6模块之中，顶层的this指向undefined，即不应该在顶层代码中使用this。

## export命令

模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

**一个模块就是一个独立的文件**。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出了变量。

~~~javascript
//profile.js 
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var lastName = 'Jackson';
~~~

上面的代码是profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了3个变量。

export的写法，除了像上面这样，还有另外一种。

~~~javascript
//profile.js 
var firstName = 'Michael';
var lastName = 'Jackson';
var lastName = 'Jackson';
export {firstName,lastName,year};
~~~

上面的代码在export命令后面使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。

export命令除了输出变量，还可以输出函数或类（class）。

~~~javascript
export function multiply(x, y) {
	return x * y;
};
~~~

上面的代码对外输出一个函数multiply。

通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。

~~~javascript
function v1(){...}
function v2(){...}

export{
	v1 as streamV1,
 	v2 as streamV2,
    v3 as streamLatestVersion
};
~~~

上面的代码使用as关键字重命名了函数v1和v2的对外接口。**重命名后，v2可以用不同的名字输出两次**。

需要特别注意的是，export命令规定的是对外的接口，**必须与模块内部的变量建立一一对应关系**。

> 没看懂这2句话是什么意思。

~~~javascript
//报错
export 1；

//报错
var m = 1;
export m;
~~~

上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m依然直接输出1，1只是一个值，不是接口。正确的写法是下面这样。

~~~javascript
//写法一
export var m = 1;

//写法二
var m = 1;
export {m};

//写法三
var n = 1;
export{n as m}；
~~~

上面3种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口取到值1。它们的实质是，**在接口名与模块内部变量之间建立了一一对应的关系**。

同样地，function和class的输出也必须遵守这样的写法。

~~~javascript
//报错
function f(){}
export f；

//正确
export function f(){}；

//正确
function f(){}
export{f}；
~~~

另外，export语句输出的接口与其对应的值是动态绑定关系，即通过该接口可以取到模块内部实时的值。

~~~javascript
export var foo = 'bar';
setTimeout(() => foo = 'baz',500);
~~~

上面的代码输出变量foo，值为bar，500ms之后变成baz。

这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见第23章。

最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为**处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷**。

~~~javascript
function foo(){
    export default 'bar'   //SyntaxError
}
foo()
~~~

上面的代码中，export语句放在函数之中，结果报错。

## import命令

使用export命令定义了模块的对外接口以后，其他Js文件就可以通过import命令加载这个模块了。

~~~javascript
//main.js
import { firstName, lastName, year} from "./profile'; 

function setName(element){
	element.textContent = firstName + '' + lastName;
}
~~~

上面的import命令用于加载`profile.js`文件，并从中输入变量。import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号中的变量名必须与被导入模块（`profile.js`）对外接口的名称相同。

如果想为输入的变量重新取一个名字，要在import命令中使用as关键字，将输入的变量重命名。

~~~javascript
import { lastName as surname ) from './profile';
~~~

import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，`.js`后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件告诉JavaScript引擎该模块的位置。

~~~javascript
import {myMethod} from "util';
~~~

上面的代码中，util是模块文件名，由于不带有路径，因此必须通过配置告诉引擎如何取到这个模块。

注意，import命令具有提升效果，会提升到整个模块的头部并首先执行。

~~~javascript
foo();
import {foo} from 'my_module';
~~~

上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，**import命令是编译阶段执行的，在代码运行之前。**

由于import是静态执行，所以**不能使用表达式和变量**，只有在运行时才能得到结果的语法结构。

~~~javascript
//报错
import { 'f' + 'oo' } from 'my module';

//报错
let module ='my module';
import {foo} from module;

//报错
if(x === 1){
	import{foo} from 'modulel';
}else{
    import{foo} from 'module2';
}
~~~

上面3种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是无法得到值的。

最后，import语句会执行所加载的模块，因此可以有下面的写法。

~~~javascript
import 'loadsh';
~~~

上面的代码仅仅执行1odash模块，但是不会输入任何值。

如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。

~~~javascript
import 'loadsh';
import 'loadsh';
~~~

上面的代码加载了两次lodash，但是只会执行一次。

~~~javascript
import {foo} from'my_module';
import {bar} from'my_module';

//等同于
import {foo，bar} from 'my_module';
~~~

上面的代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my module实例。也就是说，import语句是Singleton模式。

目前阶段，通过Babel转码，CommonJS模块的require命令和ES6模块的import命令可以写在同一个模块里面，但是最好不要这样做。**因为import在静态解析阶段执行，所以它是一个模块之中最早被执行的**。下面的代码可能不会得到预期结果。

~~~javascript
require('core-js/modules/es6.symbol');
require(' core-js/modules/es6.promise'); 
import React from ' React';
~~~

## 模块的整体加载

除了指定加载某个输出值，还可以使用整体加载（即星号*）来指定一个对象，所有输出值都加载在这个对象上。

下面是`circle.js`文件，它输出两个方法：area和circumference。

~~~javascript
//circle.js
export function area (radius){
	return Math.PI * radius * radius;
}

export function circumference (radius){
	return 2 * Math.PI * radius;
}
~~~

现在加载这个模块。

~~~javascript
//main.js
import { area,circumference } from './circle';

console.log（'圆面积：'+ area(4));
console.log（'圆周长：'+ circumference(14));
~~~

上面的写法将逐一指定要加载的方法，整体加载的写法如下。

~~~javascript
import * as circle from './circel';
console.log（'圆面积：'+ circle.area(4));
console.log（'圆周长：'+ circle.circumference(14));
~~~

注意，模块整体加载所在的对象（上例是circle）应该是可以静态分析的，所以不允许运行时改变。

下面的写法都是不允许的。

~~~javascript
import * as circle from './circel';

//下面2行都是不允许的
circle.foo = 'hello';
circle.area = function(){};
~~~

## export default命令

从前面的例子可以看出，使用import命令时用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档去了解模块有哪些属性和方法。

为了方便用户，使其不用阅读文档就能加载模块，可以使用`export default`命令为模块指定默认输出。

~~~javascript
//export-default.js
export default function(){
    console.log('foo');
}
~~~

上面的代码是一个模块文件export-default.js，它的默认输出是一个函数。

其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。

~~~javascript
//import-default.js
import customName from "./export-default';
customName (); //foo
~~~

上面的import命令可以用任意名称指向`export-defaut.js`输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面不使用大括号。

`export default`命令用在非匿名函数前也是可以的。

~~~javascript
//export-default.js
export default function foo(){
    console.log('foo');
}

//或者写成
function foo(){
    console.log('foo');
}

export default foo;
~~~

上面的代码中，foo函数的函数名foo在模块外部是无效的。加载时视同匿名函数。

下面比较一下默认输出和正常输出。

~~~javascript
//第一组
export default function crc32(){  //输出
    //...
}

import crc32 from'crc32';		  //输入

//第二组
export function crc32(){		 //输出
    //...
};

import{crc32} from 'crc32';		 //输入
~~~

上面的两组写法中，第一组使用`export default`，对应的import语句不需要使用大括号：第二组不使用export default，对应的import语句需要使用大括号。

`export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以import命令后面才不用加大括号，因为只可能对应一个方法。

本质上，`export de fault`就是输出一个叫作default的变量或方法，然后**系统允许我们为它取任意名字**。所以，下面的写法是有效的。

~~~javascript
//modules.js
function add(x,y){
    return x * y;
}
export {add as default}

//等同于
//export default add;

//app.js
import {default as xxx} from 'modules';
//等同于
//import xxx from 'modules';
~~~

正是因为export default命令其实只是输出一个叫作default的变量，所以它后面不能跟变量声明语句。

~~~javascript
//正确
export var a = -1;

//正确
var a = 1;
export default a;

//错误
export default var a = 1;
~~~

上面的代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。

同样地，因为`export default`本质是将该命令后面的值赋给default变量以后再默认，所以直接将一个值写在`export default`之后。

~~~javascript
//正确
export default 42;

//错误
export 42;
~~~

上面的代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为default。

有了`export de fault`命令，输入模块时就非常直观了，以输入lodash模块为例。

~~~javascript
import _,{each,each as ForEach} from 'loadsh';
~~~

对应上面代码的export语句如下。

~~~javascript
export default function (obj) {
    //...
}
export function each(obj, iterator, context) {
     //...
}

export { each as forEach };
~~~

上面代码最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。

export default也可以用来输出类。

~~~javascript
//MyClass.js
export default class {...}

//main.js
import MyClass from 'Myclass'; 
let o = new MyClass();
~~~

